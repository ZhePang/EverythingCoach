import {
  fs_exports,
  init_fs
} from "./chunk-RRMZLPHN.js";
import {
  require_assert
} from "./chunk-2RQIRWRR.js";
import {
  require_util
} from "./chunk-U4X5TKDG.js";
import {
  require_sha256
} from "./chunk-E6HQ72IU.js";
import {
  Connection,
  Keypair,
  NONCE_ACCOUNT_LENGTH,
  PublicKey,
  SYSVAR_RENT_PUBKEY,
  SendTransactionError,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  index_browser_esm_exports,
  init_index_browser_esm,
  require_bn,
  require_eventemitter3
} from "./chunk-6Q2MDK6K.js";
import {
  require_base64_js,
  require_bs58,
  require_buffer
} from "./chunk-ERRUAREY.js";
import {
  __commonJS,
  __esm,
  __export,
  __toModule,
  define_process_env_default,
  init_define_process_env
} from "./chunk-KP4UBDXM.js";

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports2, module) {
    init_define_process_env();
    var process2 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array3) {
      this.fun = fun;
      this.array = array3;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop() {
    }
    process2.on = noop;
    process2.addListener = noop;
    process2.once = noop;
    process2.off = noop;
    process2.removeListener = noop;
    process2.removeAllListeners = noop;
    process2.emit = noop;
    process2.prependListener = noop;
    process2.prependOnceListener = noop;
    process2.listeners = function(name) {
      return [];
    };
    process2.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/nodewallet.js
var nodewallet_exports = {};
__export(nodewallet_exports, {
  default: () => NodeWallet
});
var import_buffer, NodeWallet;
var init_nodewallet = __esm({
  "node_modules/@project-serum/anchor/dist/esm/nodewallet.js"() {
    init_define_process_env();
    import_buffer = __toModule(require_buffer());
    init_index_browser_esm();
    NodeWallet = class {
      constructor(payer) {
        this.payer = payer;
      }
      static local() {
        const process2 = require_browser();
        if (!process2.env.ANCHOR_WALLET || process2.env.ANCHOR_WALLET === "") {
          throw new Error("expected environment variable `ANCHOR_WALLET` is not set.");
        }
        const payer = Keypair.fromSecretKey(import_buffer.Buffer.from(JSON.parse((init_fs(), fs_exports).readFileSync(process2.env.ANCHOR_WALLET, {
          encoding: "utf-8"
        }))));
        return new NodeWallet(payer);
      }
      async signTransaction(tx) {
        tx.partialSign(this.payer);
        return tx;
      }
      async signAllTransactions(txs) {
        return txs.map((t) => {
          t.partialSign(this.payer);
          return t;
        });
      }
      get publicKey() {
        return this.payer.publicKey;
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/common.js
function chunks(array3, size) {
  return Array.apply(0, new Array(Math.ceil(array3.length / size))).map((_, index) => array3.slice(index * size, (index + 1) * size));
}
var _a, isBrowser;
var init_common = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/common.js"() {
    init_define_process_env();
    isBrowser = define_process_env_default.ANCHOR_BROWSER || typeof window !== "undefined" && !((_a = window.process) === null || _a === void 0 ? void 0 : _a.hasOwnProperty("type"));
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/bytes/hex.js
var hex_exports = {};
__export(hex_exports, {
  decode: () => decode,
  encode: () => encode
});
function encode(data) {
  return data.reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "0x");
}
function decode(data) {
  if (data.indexOf("0x") === 0) {
    data = data.substr(2);
  }
  if (data.length % 2 === 1) {
    data = "0" + data;
  }
  let key = data.match(/.{2}/g);
  if (key === null) {
    return import_buffer2.Buffer.from([]);
  }
  return import_buffer2.Buffer.from(key.map((byte) => parseInt(byte, 16)));
}
var import_buffer2;
var init_hex = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/bytes/hex.js"() {
    init_define_process_env();
    import_buffer2 = __toModule(require_buffer());
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/bytes/utf8.js
var utf8_exports = {};
__export(utf8_exports, {
  decode: () => decode2,
  encode: () => encode2
});
function decode2(array3) {
  const decoder = isBrowser ? new TextDecoder("utf-8") : new (require_util()).TextDecoder("utf-8");
  return decoder.decode(array3);
}
function encode2(input) {
  const encoder = isBrowser ? new TextEncoder() : new (require_util()).TextEncoder("utf-8");
  return encoder.encode(input);
}
var init_utf8 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/bytes/utf8.js"() {
    init_define_process_env();
    init_common();
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/bytes/bs58.js
var bs58_exports = {};
__export(bs58_exports, {
  decode: () => decode3,
  encode: () => encode3
});
function encode3(data) {
  return import_bs58.default.encode(data);
}
function decode3(data) {
  return import_bs58.default.decode(data);
}
var import_bs58;
var init_bs58 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/bytes/bs58.js"() {
    init_define_process_env();
    import_bs58 = __toModule(require_bs58());
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/bytes/base64.js
var base64_exports = {};
__export(base64_exports, {
  decode: () => decode4,
  encode: () => encode4
});
function encode4(data) {
  return base64.fromByteArray(data);
}
function decode4(data) {
  return import_buffer3.Buffer.from(base64.toByteArray(data));
}
var import_buffer3, base64;
var init_base64 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/bytes/base64.js"() {
    init_define_process_env();
    import_buffer3 = __toModule(require_buffer());
    base64 = __toModule(require_base64_js());
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/bytes/index.js
var bytes_exports = {};
__export(bytes_exports, {
  base64: () => base64_exports,
  bs58: () => bs58_exports,
  hex: () => hex_exports,
  utf8: () => utf8_exports
});
var init_bytes = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/bytes/index.js"() {
    init_define_process_env();
    init_hex();
    init_utf8();
    init_bs58();
    init_base64();
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/common.js
function parseIdlErrors(idl) {
  const errors = new Map();
  if (idl.errors) {
    idl.errors.forEach((e) => {
      var _a2;
      let msg = (_a2 = e.msg) !== null && _a2 !== void 0 ? _a2 : e.name;
      errors.set(e.code, msg);
    });
  }
  return errors;
}
function toInstruction(idlIx, ...args) {
  if (idlIx.args.length != args.length) {
    throw new Error("Invalid argument length");
  }
  const ix = {};
  let idx = 0;
  idlIx.args.forEach((ixArg) => {
    ix[ixArg.name] = args[idx];
    idx += 1;
  });
  return ix;
}
function validateAccounts(ixAccounts, accounts = {}) {
  ixAccounts.forEach((acc) => {
    if ("accounts" in acc) {
      validateAccounts(acc.accounts, accounts[acc.name]);
    } else {
      if (accounts[acc.name] === void 0) {
        throw new Error(`Invalid arguments: ${acc.name} not provided.`);
      }
    }
  });
}
function translateAddress(address) {
  return address instanceof PublicKey ? address : new PublicKey(address);
}
var init_common2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/common.js"() {
    init_define_process_env();
    init_index_browser_esm();
  }
});

// node_modules/@project-serum/anchor/node_modules/superstruct/lib/index.es.js
function isIterable(x) {
  return isObject(x) && typeof x[Symbol.iterator] === "function";
}
function isObject(x) {
  return typeof x === "object" && x != null;
}
function print(value) {
  return typeof value === "string" ? JSON.stringify(value) : "" + value;
}
function shiftIterator(input) {
  const {
    done,
    value
  } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct9, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type: type2
  } = struct9;
  const {
    refinement,
    message = "Expected a value of type `" + type2 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
  } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct9, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure(r, context, struct9, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct9, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    path = [],
    branch = [value],
    coerce: coerce2 = false,
    mask: mask2 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce2) {
    value = struct9.coercer(value, ctx);
    if (mask2 && struct9.type !== "type" && isObject(struct9.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct9.schema[key] === void 0) {
          delete value[key];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct9.validator(value, ctx)) {
    valid = false;
    yield [failure, void 0];
  }
  for (let [k, v, s] of struct9.entries(value, ctx)) {
    const ts = run(v, s, {
      path: k === void 0 ? path : [...path, k],
      branch: k === void 0 ? branch : [...branch, v],
      coerce: coerce2,
      mask: mask2
    });
    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], void 0];
      } else if (coerce2) {
        v = t[1];
        if (k === void 0) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject(value)) {
          value[k] = v;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct9.refiner(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
  }
  if (valid) {
    yield [void 0, value];
  }
}
function assert(value, struct9) {
  const result = validate(value, struct9);
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct9) {
  const result = validate(value, struct9, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct9) {
  const result = validate(value, struct9, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct9) {
  const result = validate(value, struct9);
  return !result[0];
}
function validate(value, struct9, options) {
  if (options === void 0) {
    options = {};
  }
  const tuples = run(value, struct9, options);
  const tuple = shiftIterator(tuples);
  if (tuple[0]) {
    const error = new StructError(tuple[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v = tuple[1];
    return [void 0, v];
  }
}
function define(name, validator) {
  return new Struct({
    type: name,
    schema: null,
    validator
  });
}
function any() {
  return define("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print(value);
    }
  });
}
function boolean() {
  return define("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function literal(constant) {
  const description = print(constant);
  const t = typeof constant;
  return new Struct({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
    }
  });
}
function nullable(struct9) {
  return new Struct({
    ...struct9,
    validator: (value, ctx) => value === null || struct9.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct9.refiner(value, ctx)
  });
}
function number() {
  return define("number", (value) => {
    return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
  });
}
function optional(struct9) {
  return new Struct({
    ...struct9,
    validator: (value, ctx) => value === void 0 || struct9.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct9.refiner(value, ctx)
  });
}
function string() {
  return define("string", (value) => {
    return typeof value === "string" || "Expected a string, but received: " + print(value);
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }
  });
}
function union(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      const firstMatch = Structs.find((s) => {
        const [e] = s.validate(value, {
          coerce: true
        });
        return !e;
      }) || unknown();
      return firstMatch.coercer(value, ctx);
    },
    validator(value, ctx) {
      const failures = [];
      for (const S of Structs) {
        const [...tuples] = run(value, S, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
    }
  });
}
function unknown() {
  return define("unknown", () => true);
}
function coerce(struct9, condition, coercer) {
  return new Struct({
    ...struct9,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct9.coercer(coercer(value, ctx), ctx) : struct9.coercer(value, ctx);
    }
  });
}
var StructError, Struct;
var init_index_es = __esm({
  "node_modules/@project-serum/anchor/node_modules/superstruct/lib/index.es.js"() {
    init_define_process_env();
    StructError = class extends TypeError {
      constructor(failure, failures) {
        let cached;
        const {
          message,
          ...rest
        } = failure;
        const {
          path
        } = failure;
        const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
        super(msg);
        this.value = void 0;
        this.key = void 0;
        this.type = void 0;
        this.refinement = void 0;
        this.path = void 0;
        this.branch = void 0;
        this.failures = void 0;
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = () => {
          var _cached;
          return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
        };
      }
    };
    Struct = class {
      constructor(props) {
        this.TYPE = void 0;
        this.type = void 0;
        this.schema = void 0;
        this.coercer = void 0;
        this.validator = void 0;
        this.refiner = void 0;
        this.entries = void 0;
        const {
          type: type2,
          schema,
          validator,
          refiner,
          coercer = (value) => value,
          entries = function* () {
          }
        } = props;
        this.type = type2;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
          this.validator = (value, context) => {
            const result = validator(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.validator = () => [];
        }
        if (refiner) {
          this.refiner = (value, context) => {
            const result = refiner(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.refiner = () => [];
        }
      }
      assert(value) {
        return assert(value, this);
      }
      create(value) {
        return create(value, this);
      }
      is(value) {
        return is(value, this);
      }
      mask(value) {
        return mask(value, this);
      }
      validate(value, options) {
        if (options === void 0) {
          options = {};
        }
        return validate(value, this, options);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/rpc.js
var rpc_exports = {};
__export(rpc_exports, {
  getMultipleAccounts: () => getMultipleAccounts,
  invoke: () => invoke,
  simulateTransaction: () => simulateTransaction
});
async function invoke(programId, accounts, data, provider) {
  programId = translateAddress(programId);
  if (!provider) {
    provider = getProvider();
  }
  const tx = new Transaction();
  tx.add(new TransactionInstruction({
    programId,
    keys: accounts !== null && accounts !== void 0 ? accounts : [],
    data
  }));
  if (provider.sendAndConfirm === void 0) {
    throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
  }
  return await provider.sendAndConfirm(tx, []);
}
async function getMultipleAccounts(connection, publicKeys, commitment) {
  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {
    return await getMultipleAccountsCore(connection, publicKeys, commitment);
  } else {
    const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);
    const results = await Promise.all(batches.map((batch) => getMultipleAccountsCore(connection, batch, commitment)));
    return results.flat();
  }
}
async function getMultipleAccountsCore(connection, publicKeys, commitmentOverride) {
  const commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;
  const accounts = await connection.getMultipleAccountsInfo(publicKeys, commitment);
  return accounts.map((account, idx) => {
    if (account === null) {
      return null;
    }
    return {
      publicKey: publicKeys[idx],
      account
    };
  });
}
async function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {
  if (signers && signers.length > 0) {
    transaction.sign(...signers);
  }
  const message = transaction._compile();
  const signData = message.serialize();
  const wireTransaction = transaction._serialize(signData);
  const encodedTransaction = wireTransaction.toString("base64");
  const config = {
    encoding: "base64",
    commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment
  };
  if (includeAccounts) {
    const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
    config["accounts"] = {
      encoding: "base64",
      addresses
    };
  }
  if (signers) {
    config.sigVerify = true;
  }
  const args = [encodedTransaction, config];
  const unsafeRes = await connection._rpcRequest("simulateTransaction", args);
  const res = create(unsafeRes, SimulatedTransactionResponseStruct);
  if ("error" in res) {
    let logs;
    if ("data" in res.error) {
      logs = res.error.data.logs;
      if (logs && Array.isArray(logs)) {
        const traceIndent = "\n    ";
        const logTrace = traceIndent + logs.join(traceIndent);
        console.error(res.error.message, logTrace);
      }
    }
    throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
  }
  return res.result;
}
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function createRpcResult(result) {
  return union([
    type({
      jsonrpc: literal("2.0"),
      id: string(),
      result
    }),
    type({
      jsonrpc: literal("2.0"),
      id: string(),
      error: type({
        code: unknown(),
        message: string(),
        data: optional(any())
      })
    })
  ]);
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value
  }));
}
var GET_MULTIPLE_ACCOUNTS_LIMIT, UnknownRpcResult, SimulatedTransactionResponseStruct;
var init_rpc = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/rpc.js"() {
    init_define_process_env();
    init_index_browser_esm();
    init_common();
    init_common2();
    init_provider();
    init_index_es();
    GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
    UnknownRpcResult = createRpcResult(unknown());
    SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
      err: nullable(union([type({}), string()])),
      logs: nullable(array(string())),
      accounts: optional(nullable(array(nullable(type({
        executable: boolean(),
        owner: string(),
        lamports: number(),
        data: array(string()),
        rentEpoch: optional(number())
      }))))),
      unitsConsumed: optional(number())
    }));
  }
});

// node_modules/@project-serum/anchor/dist/esm/provider.js
async function sendAndConfirmRawTransaction(connection, rawTransaction, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment
  };
  const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  if (status.err) {
    throw new ConfirmError(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
function setProvider(provider) {
  _provider = provider;
}
function getProvider() {
  if (_provider === null) {
    return AnchorProvider.local();
  }
  return _provider;
}
var AnchorProvider, SimulateError, ConfirmError, _provider;
var init_provider = __esm({
  "node_modules/@project-serum/anchor/dist/esm/provider.js"() {
    init_define_process_env();
    init_index_browser_esm();
    init_bytes();
    init_common();
    init_rpc();
    AnchorProvider = class {
      constructor(connection, wallet, opts) {
        this.connection = connection;
        this.wallet = wallet;
        this.opts = opts;
        this.publicKey = wallet.publicKey;
      }
      static defaultOptions() {
        return {
          preflightCommitment: "processed",
          commitment: "processed"
        };
      }
      static local(url, opts) {
        if (isBrowser) {
          throw new Error(`Provider local is not available on browser.`);
        }
        opts = opts !== null && opts !== void 0 ? opts : AnchorProvider.defaultOptions();
        const connection = new Connection(url !== null && url !== void 0 ? url : "http://localhost:8899", opts.preflightCommitment);
        const NodeWallet2 = (init_nodewallet(), nodewallet_exports).default;
        const wallet = NodeWallet2.local();
        return new AnchorProvider(connection, wallet, opts);
      }
      static env() {
        if (isBrowser) {
          throw new Error(`Provider env is not available on browser.`);
        }
        const process2 = require_browser();
        const url = process2.env.ANCHOR_PROVIDER_URL;
        if (url === void 0) {
          throw new Error("ANCHOR_PROVIDER_URL is not defined");
        }
        const options = AnchorProvider.defaultOptions();
        const connection = new Connection(url, options.commitment);
        const NodeWallet2 = (init_nodewallet(), nodewallet_exports).default;
        const wallet = NodeWallet2.local();
        return new AnchorProvider(connection, wallet, options);
      }
      async sendAndConfirm(tx, signers, opts) {
        var _a2;
        if (opts === void 0) {
          opts = this.opts;
        }
        tx.feePayer = this.wallet.publicKey;
        tx.recentBlockhash = (await this.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;
        tx = await this.wallet.signTransaction(tx);
        (signers !== null && signers !== void 0 ? signers : []).forEach((kp) => {
          tx.partialSign(kp);
        });
        const rawTx = tx.serialize();
        try {
          return await sendAndConfirmRawTransaction(this.connection, rawTx, opts);
        } catch (err2) {
          if (err2 instanceof ConfirmError) {
            const failedTx = await this.connection.getTransaction(bs58_exports.encode(tx.signature), { commitment: "confirmed" });
            if (!failedTx) {
              throw err2;
            } else {
              const logs = (_a2 = failedTx.meta) === null || _a2 === void 0 ? void 0 : _a2.logMessages;
              throw !logs ? err2 : new SendTransactionError(err2.message, logs);
            }
          } else {
            throw err2;
          }
        }
      }
      async sendAll(txWithSigners, opts) {
        if (opts === void 0) {
          opts = this.opts;
        }
        const blockhash = await this.connection.getRecentBlockhash(opts.preflightCommitment);
        let txs = txWithSigners.map((r) => {
          var _a2;
          let tx = r.tx;
          let signers = (_a2 = r.signers) !== null && _a2 !== void 0 ? _a2 : [];
          tx.feePayer = this.wallet.publicKey;
          tx.recentBlockhash = blockhash.blockhash;
          signers.forEach((kp) => {
            tx.partialSign(kp);
          });
          return tx;
        });
        const signedTxs = await this.wallet.signAllTransactions(txs);
        const sigs = [];
        for (let k = 0; k < txs.length; k += 1) {
          const tx = signedTxs[k];
          const rawTx = tx.serialize();
          sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));
        }
        return sigs;
      }
      async simulate(tx, signers, commitment, includeAccounts) {
        tx.feePayer = this.wallet.publicKey;
        tx.recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;
        tx = await this.wallet.signTransaction(tx);
        const result = await simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);
        if (result.value.err) {
          throw new SimulateError(result.value);
        }
        return result.value;
      }
    };
    SimulateError = class extends Error {
      constructor(simulationResponse, message) {
        super(message);
        this.simulationResponse = simulationResponse;
      }
    };
    ConfirmError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    _provider = null;
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/features.js
var features_exports = {};
__export(features_exports, {
  isSet: () => isSet,
  set: () => set
});
function set(key) {
  if (!_AVAILABLE_FEATURES.has(key)) {
    throw new Error("Invalid feature");
  }
  _FEATURES.set(key, true);
}
function isSet(key) {
  return _FEATURES.get(key) !== void 0;
}
var _AVAILABLE_FEATURES, _FEATURES;
var init_features = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/features.js"() {
    init_define_process_env();
    _AVAILABLE_FEATURES = new Set(["anchor-deprecated-state", "debug-logs"]);
    _FEATURES = new Map();
  }
});

// node_modules/@project-serum/anchor/dist/esm/error.js
function translateError(err2, idlErrors) {
  if (isSet("debug-logs")) {
    console.log("Translating error:", err2);
  }
  const anchorError = AnchorError.parse(err2.logs);
  if (anchorError) {
    return anchorError;
  }
  const programError = ProgramError.parse(err2, idlErrors);
  if (programError) {
    return programError;
  }
  if (err2.logs) {
    const handler = {
      get: function(target, prop) {
        if (prop === "programErrorStack") {
          return target.programErrorStack.stack;
        } else if (prop === "program") {
          return target.programErrorStack.stack[err2.programErrorStack.stack.length - 1];
        } else {
          return Reflect.get(...arguments);
        }
      }
    };
    err2.programErrorStack = ProgramErrorStack.parse(err2.logs);
    return new Proxy(err2, handler);
  }
  return err2;
}
var IdlError, ProgramErrorStack, AnchorError, ProgramError, LangErrorCode, LangErrorMessage;
var init_error = __esm({
  "node_modules/@project-serum/anchor/dist/esm/error.js"() {
    init_define_process_env();
    init_index_browser_esm();
    init_features();
    IdlError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "IdlError";
      }
    };
    ProgramErrorStack = class {
      constructor(stack) {
        this.stack = stack;
      }
      static parse(logs) {
        var _a2;
        const programKeyRegex = /^Program (\w*) invoke/;
        const successRegex = /^Program \w* success/;
        const programStack = [];
        for (let i = 0; i < logs.length; i++) {
          if (successRegex.exec(logs[i])) {
            programStack.pop();
            continue;
          }
          const programKey = (_a2 = programKeyRegex.exec(logs[i])) === null || _a2 === void 0 ? void 0 : _a2[1];
          if (!programKey) {
            continue;
          }
          programStack.push(new PublicKey(programKey));
        }
        return new ProgramErrorStack(programStack);
      }
    };
    AnchorError = class extends Error {
      constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {
        super(errorLogs.join("\n").replace("Program log: ", ""));
        this.errorLogs = errorLogs;
        this.logs = logs;
        this.error = { errorCode, errorMessage, comparedValues, origin };
        this._programErrorStack = ProgramErrorStack.parse(logs);
      }
      static parse(logs) {
        if (!logs) {
          return null;
        }
        const anchorErrorLogIndex = logs.findIndex((log) => log.startsWith("Program log: AnchorError"));
        if (anchorErrorLogIndex === -1) {
          return null;
        }
        const anchorErrorLog = logs[anchorErrorLogIndex];
        const errorLogs = [anchorErrorLog];
        let comparedValues;
        if (anchorErrorLogIndex + 1 < logs.length) {
          if (logs[anchorErrorLogIndex + 1] === "Program log: Left:") {
            const pubkeyRegex = /^Program log: (.*)$/;
            const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];
            const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];
            comparedValues = [
              new PublicKey(leftPubkey),
              new PublicKey(rightPubkey)
            ];
            errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));
          } else if (logs[anchorErrorLogIndex + 1].startsWith("Program log: Left:")) {
            const valueRegex = /^Program log: (Left|Right): (.*)$/;
            const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];
            const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];
            errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));
            comparedValues = [leftValue, rightValue];
          }
        }
        const regexNoInfo = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
        const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);
        const regexFileLine = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
        const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);
        const regexAccountName = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
        const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);
        if (noInfoAnchorErrorLog) {
          const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);
          const errorCode = {
            code: errorCodeString,
            number: parseInt(errorNumber)
          };
          return new AnchorError(errorCode, errorMessage, errorLogs, logs, void 0, comparedValues);
        } else if (fileLineAnchorErrorLog) {
          const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);
          const errorCode = {
            code: errorCodeString,
            number: parseInt(errorNumber)
          };
          const fileLine = { file, line: parseInt(line) };
          return new AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);
        } else if (accountNameAnchorErrorLog) {
          const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);
          const origin = accountName;
          const errorCode = {
            code: errorCodeString,
            number: parseInt(errorNumber)
          };
          return new AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);
        } else {
          return null;
        }
      }
      get program() {
        return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
      }
      get programErrorStack() {
        return this._programErrorStack.stack;
      }
      toString() {
        return this.message;
      }
    };
    ProgramError = class extends Error {
      constructor(code, msg, logs) {
        super();
        this.code = code;
        this.msg = msg;
        this.logs = logs;
        if (logs) {
          this._programErrorStack = ProgramErrorStack.parse(logs);
        }
      }
      static parse(err2, idlErrors) {
        const errString = err2.toString();
        let unparsedErrorCode;
        if (errString.includes("custom program error:")) {
          let components = errString.split("custom program error: ");
          if (components.length !== 2) {
            return null;
          } else {
            unparsedErrorCode = components[1];
          }
        } else {
          const matches = errString.match(/"Custom":([0-9]+)}/g);
          if (!matches || matches.length > 1) {
            return null;
          }
          unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];
        }
        let errorCode;
        try {
          errorCode = parseInt(unparsedErrorCode);
        } catch (parseErr) {
          return null;
        }
        let errorMsg = idlErrors.get(errorCode);
        if (errorMsg !== void 0) {
          return new ProgramError(errorCode, errorMsg, err2.logs);
        }
        errorMsg = LangErrorMessage.get(errorCode);
        if (errorMsg !== void 0) {
          return new ProgramError(errorCode, errorMsg, err2.logs);
        }
        return null;
      }
      get program() {
        var _a2;
        return (_a2 = this._programErrorStack) === null || _a2 === void 0 ? void 0 : _a2.stack[this._programErrorStack.stack.length - 1];
      }
      get programErrorStack() {
        var _a2;
        return (_a2 = this._programErrorStack) === null || _a2 === void 0 ? void 0 : _a2.stack;
      }
      toString() {
        return this.msg;
      }
    };
    LangErrorCode = {
      InstructionMissing: 100,
      InstructionFallbackNotFound: 101,
      InstructionDidNotDeserialize: 102,
      InstructionDidNotSerialize: 103,
      IdlInstructionStub: 1e3,
      IdlInstructionInvalidProgram: 1001,
      ConstraintMut: 2e3,
      ConstraintHasOne: 2001,
      ConstraintSigner: 2002,
      ConstraintRaw: 2003,
      ConstraintOwner: 2004,
      ConstraintRentExempt: 2005,
      ConstraintSeeds: 2006,
      ConstraintExecutable: 2007,
      ConstraintState: 2008,
      ConstraintAssociated: 2009,
      ConstraintAssociatedInit: 2010,
      ConstraintClose: 2011,
      ConstraintAddress: 2012,
      ConstraintZero: 2013,
      ConstraintTokenMint: 2014,
      ConstraintTokenOwner: 2015,
      ConstraintMintMintAuthority: 2016,
      ConstraintMintFreezeAuthority: 2017,
      ConstraintMintDecimals: 2018,
      ConstraintSpace: 2019,
      RequireViolated: 2500,
      RequireEqViolated: 2501,
      RequireKeysEqViolated: 2502,
      RequireNeqViolated: 2503,
      RequireKeysNeqViolated: 2504,
      RequireGtViolated: 2505,
      RequireGteViolated: 2506,
      AccountDiscriminatorAlreadySet: 3e3,
      AccountDiscriminatorNotFound: 3001,
      AccountDiscriminatorMismatch: 3002,
      AccountDidNotDeserialize: 3003,
      AccountDidNotSerialize: 3004,
      AccountNotEnoughKeys: 3005,
      AccountNotMutable: 3006,
      AccountOwnedByWrongProgram: 3007,
      InvalidProgramId: 3008,
      InvalidProgramExecutable: 3009,
      AccountNotSigner: 3010,
      AccountNotSystemOwned: 3011,
      AccountNotInitialized: 3012,
      AccountNotProgramData: 3013,
      AccountNotAssociatedTokenAccount: 3014,
      AccountSysvarMismatch: 3015,
      AccountReallocExceedsLimit: 3016,
      AccountDuplicateReallocs: 3017,
      StateInvalidAddress: 4e3,
      DeclaredProgramIdMismatch: 4100,
      Deprecated: 5e3
    };
    LangErrorMessage = new Map([
      [
        LangErrorCode.InstructionMissing,
        "8 byte instruction identifier not provided"
      ],
      [
        LangErrorCode.InstructionFallbackNotFound,
        "Fallback functions are not supported"
      ],
      [
        LangErrorCode.InstructionDidNotDeserialize,
        "The program could not deserialize the given instruction"
      ],
      [
        LangErrorCode.InstructionDidNotSerialize,
        "The program could not serialize the given instruction"
      ],
      [
        LangErrorCode.IdlInstructionStub,
        "The program was compiled without idl instructions"
      ],
      [
        LangErrorCode.IdlInstructionInvalidProgram,
        "The transaction was given an invalid program for the IDL instruction"
      ],
      [LangErrorCode.ConstraintMut, "A mut constraint was violated"],
      [LangErrorCode.ConstraintHasOne, "A has_one constraint was violated"],
      [LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
      [LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
      [LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
      [
        LangErrorCode.ConstraintRentExempt,
        "A rent exemption constraint was violated"
      ],
      [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
      [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
      [LangErrorCode.ConstraintState, "A state constraint was violated"],
      [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
      [
        LangErrorCode.ConstraintAssociatedInit,
        "An associated init constraint was violated"
      ],
      [LangErrorCode.ConstraintClose, "A close constraint was violated"],
      [LangErrorCode.ConstraintAddress, "An address constraint was violated"],
      [LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
      [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
      [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
      [
        LangErrorCode.ConstraintMintMintAuthority,
        "A mint mint authority constraint was violated"
      ],
      [
        LangErrorCode.ConstraintMintFreezeAuthority,
        "A mint freeze authority constraint was violated"
      ],
      [
        LangErrorCode.ConstraintMintDecimals,
        "A mint decimals constraint was violated"
      ],
      [LangErrorCode.ConstraintSpace, "A space constraint was violated"],
      [LangErrorCode.RequireViolated, "A require expression was violated"],
      [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"],
      [
        LangErrorCode.RequireKeysEqViolated,
        "A require_keys_eq expression was violated"
      ],
      [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"],
      [
        LangErrorCode.RequireKeysNeqViolated,
        "A require_keys_neq expression was violated"
      ],
      [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"],
      [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"],
      [
        LangErrorCode.AccountDiscriminatorAlreadySet,
        "The account discriminator was already set on this account"
      ],
      [
        LangErrorCode.AccountDiscriminatorNotFound,
        "No 8 byte discriminator was found on the account"
      ],
      [
        LangErrorCode.AccountDiscriminatorMismatch,
        "8 byte discriminator did not match what was expected"
      ],
      [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
      [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
      [
        LangErrorCode.AccountNotEnoughKeys,
        "Not enough account keys given to the instruction"
      ],
      [LangErrorCode.AccountNotMutable, "The given account is not mutable"],
      [
        LangErrorCode.AccountOwnedByWrongProgram,
        "The given account is owned by a different program than expected"
      ],
      [LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
      [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
      [LangErrorCode.AccountNotSigner, "The given account did not sign"],
      [
        LangErrorCode.AccountNotSystemOwned,
        "The given account is not owned by the system program"
      ],
      [
        LangErrorCode.AccountNotInitialized,
        "The program expected this account to be already initialized"
      ],
      [
        LangErrorCode.AccountNotProgramData,
        "The given account is not a program data account"
      ],
      [
        LangErrorCode.AccountNotAssociatedTokenAccount,
        "The given account is not the associated token account"
      ],
      [
        LangErrorCode.AccountSysvarMismatch,
        "The given public key does not match the required sysvar"
      ],
      [
        LangErrorCode.AccountReallocExceedsLimit,
        "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"
      ],
      [
        LangErrorCode.AccountDuplicateReallocs,
        "The account was duplicated for more than one reallocation"
      ],
      [
        LangErrorCode.StateInvalidAddress,
        "The given state account does not have the correct address"
      ],
      [
        LangErrorCode.DeclaredProgramIdMismatch,
        "The declared program id does not match the actual program id"
      ],
      [
        LangErrorCode.Deprecated,
        "The API being used is deprecated and should no longer be used"
      ]
    ]);
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports2, module) {
    init_define_process_env();
    "use strict";
    var preserveCamelCase = (string2) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string2.length; i++) {
        const character = string2[i];
        if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
          string2 = string2.slice(0, i) + "-" + string2.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
          string2 = string2.slice(0, i - 1) + "-" + string2.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
        }
      }
      return string2;
    };
    var camelCase11 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = Object.assign({
        pascalCase: false
      }, options);
      const postProcess = (x) => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
      }
      const hasUpperCase = input !== input.toLowerCase();
      if (hasUpperCase) {
        input = preserveCamelCase(input);
      }
      input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
      return postProcess(input);
    };
    module.exports = camelCase11;
    module.exports.default = camelCase11;
  }
});

// node_modules/tslib/tslib.es6.js
var __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    init_define_process_env();
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/lower-case/dist.es2015/index.js
function lowerCase(str2) {
  return str2.toLowerCase();
}
var init_dist = __esm({
  "node_modules/lower-case/dist.es2015/index.js"() {
    init_define_process_env();
  }
});

// node_modules/no-case/dist.es2015/index.js
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.splitRegexp, splitRegexp = _a2 === void 0 ? DEFAULT_SPLIT_REGEXP : _a2, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
var DEFAULT_SPLIT_REGEXP, DEFAULT_STRIP_REGEXP;
var init_dist2 = __esm({
  "node_modules/no-case/dist.es2015/index.js"() {
    init_define_process_env();
    init_dist();
    DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  }
});

// node_modules/dot-case/dist.es2015/index.js
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "." }, options));
}
var init_dist3 = __esm({
  "node_modules/dot-case/dist.es2015/index.js"() {
    init_define_process_env();
    init_tslib_es6();
    init_dist2();
  }
});

// node_modules/snake-case/dist.es2015/index.js
function snakeCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign({ delimiter: "_" }, options));
}
var init_dist4 = __esm({
  "node_modules/snake-case/dist.es2015/index.js"() {
    init_define_process_env();
    init_tslib_es6();
    init_dist3();
  }
});

// node_modules/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "node_modules/buffer-layout/lib/Layout.js"(exports2) {
    init_define_process_env();
    "use strict";
    var Layout4 = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      makeDestinationObject() {
        return {};
      }
      decode(b, offset2) {
        throw new Error("Layout is abstract");
      }
      encode(src, b, offset2) {
        throw new Error("Layout is abstract");
      }
      getSpan(b, offset2) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout4;
    function nameWithProperty(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty;
    function bindConstructorLayout(Class, layout) {
      if (typeof Class !== "function") {
        throw new TypeError("Class must be constructor");
      }
      if (Class.hasOwnProperty("layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout4)) {
        throw new TypeError("layout must be a Layout");
      }
      if (layout.hasOwnProperty("boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value: function(b, offset2) {
          return layout.encode(this, b, offset2);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value: function(b, offset2) {
          return layout.decode(b, offset2);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout = class extends Layout4 {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    var GreedyCount = class extends ExternalLayout {
      constructor(elementSpan, property) {
        if (elementSpan === void 0) {
          elementSpan = 1;
        }
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      isCount() {
        return true;
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const rem = b.length - offset2;
        return Math.floor(rem / this.elementSpan);
      }
      encode(src, b, offset2) {
        return 0;
      }
    };
    var OffsetLayout = class extends ExternalLayout {
      constructor(layout, offset2, property) {
        if (!(layout instanceof Layout4)) {
          throw new TypeError("layout must be a Layout");
        }
        if (offset2 === void 0) {
          offset2 = 0;
        } else if (!Number.isInteger(offset2)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset2;
      }
      isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return this.layout.decode(b, offset2 + this.offset);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return this.layout.encode(src, b, offset2 + this.offset);
      }
    };
    var UInt = class extends Layout4 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.readUIntLE(offset2, this.span);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        b.writeUIntLE(src, offset2, this.span);
        return this.span;
      }
    };
    var UIntBE = class extends Layout4 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.readUIntBE(offset2, this.span);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        b.writeUIntBE(src, offset2, this.span);
        return this.span;
      }
    };
    var Int = class extends Layout4 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.readIntLE(offset2, this.span);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        b.writeIntLE(src, offset2, this.span);
        return this.span;
      }
    };
    var IntBE = class extends Layout4 {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.readIntBE(offset2, this.span);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        b.writeIntBE(src, offset2, this.span);
        return this.span;
      }
    };
    var V2E32 = Math.pow(2, 32);
    function divmodInt64(src) {
      const hi32 = Math.floor(src / V2E32);
      const lo32 = src - hi32 * V2E32;
      return { hi32, lo32 };
    }
    function roundedInt64(hi32, lo32) {
      return hi32 * V2E32 + lo32;
    }
    var NearUInt64 = class extends Layout4 {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const lo32 = b.readUInt32LE(offset2);
        const hi32 = b.readUInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32LE(split.lo32, offset2);
        b.writeUInt32LE(split.hi32, offset2 + 4);
        return 8;
      }
    };
    var NearUInt64BE = class extends Layout4 {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const hi32 = b.readUInt32BE(offset2);
        const lo32 = b.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32BE(split.hi32, offset2);
        b.writeUInt32BE(split.lo32, offset2 + 4);
        return 8;
      }
    };
    var NearInt64 = class extends Layout4 {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const lo32 = b.readUInt32LE(offset2);
        const hi32 = b.readInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const split = divmodInt64(src);
        b.writeUInt32LE(split.lo32, offset2);
        b.writeInt32LE(split.hi32, offset2 + 4);
        return 8;
      }
    };
    var NearInt64BE = class extends Layout4 {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const hi32 = b.readInt32BE(offset2);
        const lo32 = b.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const split = divmodInt64(src);
        b.writeInt32BE(split.hi32, offset2);
        b.writeUInt32BE(split.lo32, offset2 + 4);
        return 8;
      }
    };
    var Float = class extends Layout4 {
      constructor(property) {
        super(4, property);
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.readFloatLE(offset2);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        b.writeFloatLE(src, offset2);
        return 4;
      }
    };
    var FloatBE = class extends Layout4 {
      constructor(property) {
        super(4, property);
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.readFloatBE(offset2);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        b.writeFloatBE(src, offset2);
        return 4;
      }
    };
    var Double = class extends Layout4 {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.readDoubleLE(offset2);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        b.writeDoubleLE(src, offset2);
        return 8;
      }
    };
    var DoubleBE = class extends Layout4 {
      constructor(property) {
        super(8, property);
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.readDoubleBE(offset2);
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        b.writeDoubleBE(src, offset2);
        return 8;
      }
    };
    var Sequence = class extends Layout4 {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout4)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      getSpan(b, offset2) {
        if (0 <= this.span) {
          return this.span;
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset2);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset2 + span);
            ++idx;
          }
        }
        return span;
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset2);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset2));
          offset2 += this.elementLayout.getSpan(b, offset2);
          i += 1;
        }
        return rv;
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const elo = this.elementLayout;
        const span = src.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset2 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b, offset2);
        }
        return span;
      }
    };
    var Structure = class extends Layout4 {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout4, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if (typeof property === "boolean" && decodePrefixes === void 0) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && fd.property === void 0) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      getSpan(b, offset2) {
        if (0 <= this.span) {
          return this.span;
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset2);
            offset2 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (fd.property !== void 0) {
            dest[fd.property] = fd.decode(b, offset2);
          }
          offset2 += fd.getSpan(b, offset2);
          if (this.decodePrefixes && b.length === offset2) {
            break;
          }
        }
        return dest;
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const firstOffset = offset2;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (fd.property !== void 0) {
            const fv = src[fd.property];
            if (fv !== void 0) {
              lastWrote = fd.encode(fv, b, offset2);
              if (0 > span) {
                span = fd.getSpan(b, offset2);
              }
            }
          }
          lastOffset = offset2;
          offset2 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (fd.property !== void 0 && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      layoutFor(property) {
        if (typeof property !== "string") {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
      offsetOf(property) {
        if (typeof property !== "string") {
          throw new TypeError("property must be string");
        }
        let offset2 = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset2;
          }
          if (0 > fd.span) {
            offset2 = -1;
          } else if (0 <= offset2) {
            offset2 += fd.span;
          }
        }
      }
    };
    var UnionDiscriminator = class {
      constructor(property) {
        this.property = property;
      }
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    var UnionLayoutDiscriminator = class extends UnionDiscriminator {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      decode(b, offset2) {
        return this.layout.decode(b, offset2);
      }
      encode(src, b, offset2) {
        return this.layout.encode(src, b, offset2);
      }
    };
    var Union = class extends Layout4 {
      constructor(discr, defaultLayout, property) {
        const upv = discr instanceof UInt || discr instanceof UIntBE;
        if (upv) {
          discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discr = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        }
        if (defaultLayout === void 0) {
          defaultLayout = null;
        }
        if (!(defaultLayout === null || defaultLayout instanceof Layout4)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (defaultLayout !== null) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (defaultLayout.property === void 0) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && upv) {
            span += discr.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discr;
        this.usesPrefixDiscriminator = upv;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      getSpan(b, offset2) {
        if (0 <= this.span) {
          return this.span;
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const vlo = this.getVariant(b, offset2);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset2);
      }
      defaultGetSourceVariant(src) {
        if (src.hasOwnProperty(this.discriminator.property)) {
          if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (src.hasOwnProperty(vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset2);
        let clo = this.registry[discr];
        if (clo === void 0) {
          let contentOffset = 0;
          clo = this.defaultLayout;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[clo.property] = this.defaultLayout.decode(b, offset2 + contentOffset);
        } else {
          dest = clo.decode(b, offset2);
        }
        return dest;
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const vlo = this.getSourceVariant(src);
        if (vlo === void 0) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b, offset2);
          return contentOffset + clo.encode(src[clo.property], b, offset2 + contentOffset);
        }
        return vlo.encode(src, b, offset2);
      }
      addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      getVariant(vb, offset2) {
        let variant = vb;
        if (Buffer.isBuffer(vb)) {
          if (offset2 === void 0) {
            offset2 = 0;
          }
          variant = this.discriminator.decode(vb, offset2);
        }
        return this.registry[variant];
      }
    };
    var VariantLayout = class extends Layout4 {
      constructor(union4, variant, layout, property) {
        if (!(union4 instanceof Union)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if (typeof layout === "string" && property === void 0) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout4)) {
            throw new TypeError("layout must be a Layout");
          }
          if (union4.defaultLayout !== null && 0 <= layout.span && layout.span > union4.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if (typeof property !== "string") {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union4.span;
        if (0 > union4.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union4.usesPrefixDiscriminator) {
            span += union4.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union4;
        this.variant = variant;
        this.layout = layout || null;
      }
      getSpan(b, offset2) {
        if (0 <= this.span) {
          return this.span;
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        return contentOffset + this.layout.getSpan(b, offset2 + contentOffset);
      }
      decode(b, offset2) {
        const dest = this.makeDestinationObject();
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (this !== this.union.getVariant(b, offset2)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !src.hasOwnProperty(this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset2);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b, offset2 + contentOffset);
          span += this.layout.getSpan(b, offset2 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
      }
    };
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure = class extends Layout4 {
      constructor(word, msb, property) {
        if (!(word instanceof UInt || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if (typeof msb === "string" && property === void 0) {
          property = msb;
          msb = void 0;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      decode(b, offset2) {
        const dest = this.makeDestinationObject();
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const value = this.word.decode(b, offset2);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (fd.property !== void 0) {
            dest[fd.property] = fd.decode(value);
          }
        }
        return dest;
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        const value = this.word.decode(b, offset2);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (fd.property !== void 0) {
            const fv = src[fd.property];
            if (fv !== void 0) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset2);
      }
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      addBoolean(property) {
        const bf = new Boolean(this, property);
        this.fields.push(bf);
        return bf;
      }
      fieldFor(property) {
        if (typeof property !== "string") {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
    };
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (bits === 32) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      decode() {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      encode(value) {
        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    var Boolean = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      decode(b, offset2) {
        return !!BitField.prototype.decode.call(this, b, offset2);
      }
      encode(value) {
        if (typeof value === "boolean") {
          value = +value;
        }
        return BitField.prototype.encode.call(this, value);
      }
    };
    var Blob2 = class extends Layout4 {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      getSpan(b, offset2) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset2);
        }
        return span;
      }
      decode(b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset2);
        }
        return b.slice(offset2, offset2 + span);
      }
      encode(src, b, offset2) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }
        if (!(Buffer.isBuffer(src) && span === src.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
        }
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        b.write(src.toString("hex"), offset2, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b, offset2);
        }
        return span;
      }
    };
    var CString = class extends Layout4 {
      constructor(property) {
        super(-1, property);
      }
      getSpan(b, offset2) {
        if (!Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let idx = offset2;
        while (idx < b.length && b[idx] !== 0) {
          idx += 1;
        }
        return 1 + idx - offset2;
      }
      decode(b, offset2, dest) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let span = this.getSpan(b, offset2);
        return b.slice(offset2, offset2 + span - 1).toString("utf-8");
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (typeof src !== "string") {
          src = src.toString();
        }
        const srcb = new Buffer(src, "utf8");
        const span = srcb.length;
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset2);
        b[offset2 + span] = 0;
        return span + 1;
      }
    };
    var UTF8 = class extends Layout4 {
      constructor(maxSpan, property) {
        if (typeof maxSpan === "string" && property === void 0) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (maxSpan === void 0) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      getSpan(b, offset2) {
        if (!Buffer.isBuffer(b)) {
          throw new TypeError("b must be a Buffer");
        }
        if (offset2 === void 0) {
          offset2 = 0;
        }
        return b.length - offset2;
      }
      decode(b, offset2, dest) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        let span = this.getSpan(b, offset2);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return b.slice(offset2, offset2 + span).toString("utf-8");
      }
      encode(src, b, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (typeof src !== "string") {
          src = src.toString();
        }
        const srcb = new Buffer(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b, offset2);
        return span;
      }
    };
    var Constant = class extends Layout4 {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      decode(b, offset2, dest) {
        return this.value;
      }
      encode(src, b, offset2) {
        return 0;
      }
    };
    exports2.ExternalLayout = ExternalLayout;
    exports2.GreedyCount = GreedyCount;
    exports2.OffsetLayout = OffsetLayout;
    exports2.UInt = UInt;
    exports2.UIntBE = UIntBE;
    exports2.Int = Int;
    exports2.IntBE = IntBE;
    exports2.Float = Float;
    exports2.FloatBE = FloatBE;
    exports2.Double = Double;
    exports2.DoubleBE = DoubleBE;
    exports2.Sequence = Sequence;
    exports2.Structure = Structure;
    exports2.UnionDiscriminator = UnionDiscriminator;
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    exports2.Union = Union;
    exports2.VariantLayout = VariantLayout;
    exports2.BitStructure = BitStructure;
    exports2.BitField = BitField;
    exports2.Boolean = Boolean;
    exports2.Blob = Blob2;
    exports2.CString = CString;
    exports2.UTF8 = UTF8;
    exports2.Constant = Constant;
    exports2.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports2.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
    exports2.u8 = (property) => new UInt(1, property);
    exports2.u16 = (property) => new UInt(2, property);
    exports2.u24 = (property) => new UInt(3, property);
    exports2.u32 = (property) => new UInt(4, property);
    exports2.u40 = (property) => new UInt(5, property);
    exports2.u48 = (property) => new UInt(6, property);
    exports2.nu64 = (property) => new NearUInt64(property);
    exports2.u16be = (property) => new UIntBE(2, property);
    exports2.u24be = (property) => new UIntBE(3, property);
    exports2.u32be = (property) => new UIntBE(4, property);
    exports2.u40be = (property) => new UIntBE(5, property);
    exports2.u48be = (property) => new UIntBE(6, property);
    exports2.nu64be = (property) => new NearUInt64BE(property);
    exports2.s8 = (property) => new Int(1, property);
    exports2.s16 = (property) => new Int(2, property);
    exports2.s24 = (property) => new Int(3, property);
    exports2.s32 = (property) => new Int(4, property);
    exports2.s40 = (property) => new Int(5, property);
    exports2.s48 = (property) => new Int(6, property);
    exports2.ns64 = (property) => new NearInt64(property);
    exports2.s16be = (property) => new IntBE(2, property);
    exports2.s24be = (property) => new IntBE(3, property);
    exports2.s32be = (property) => new IntBE(4, property);
    exports2.s40be = (property) => new IntBE(5, property);
    exports2.s48be = (property) => new IntBE(6, property);
    exports2.ns64be = (property) => new NearInt64BE(property);
    exports2.f32 = (property) => new Float(property);
    exports2.f32be = (property) => new FloatBE(property);
    exports2.f64 = (property) => new Double(property);
    exports2.f64be = (property) => new DoubleBE(property);
    exports2.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
    exports2.bits = (word, msb, property) => new BitStructure(word, msb, property);
    exports2.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports2.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
    exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
    exports2.blob = (length, property) => new Blob2(length, property);
    exports2.cstr = (property) => new CString(property);
    exports2.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports2.const = (value, property) => new Constant(value, property);
  }
});

// node_modules/@project-serum/borsh/dist/lib/index.js
var require_lib = __commonJS({
  "node_modules/@project-serum/borsh/dist/lib/index.js"(exports2) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.map = exports2.array = exports2.rustEnum = exports2.str = exports2.vecU8 = exports2.tagged = exports2.vec = exports2.bool = exports2.option = exports2.publicKey = exports2.i128 = exports2.u128 = exports2.i64 = exports2.u64 = exports2.struct = exports2.f64 = exports2.f32 = exports2.i32 = exports2.u32 = exports2.i16 = exports2.u16 = exports2.i8 = exports2.u8 = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), index_browser_esm_exports);
    var bn_js_1 = __importDefault(require_bn());
    var buffer_layout_2 = require_Layout();
    Object.defineProperty(exports2, "u8", { enumerable: true, get: function() {
      return buffer_layout_2.u8;
    } });
    Object.defineProperty(exports2, "i8", { enumerable: true, get: function() {
      return buffer_layout_2.s8;
    } });
    Object.defineProperty(exports2, "u16", { enumerable: true, get: function() {
      return buffer_layout_2.u16;
    } });
    Object.defineProperty(exports2, "i16", { enumerable: true, get: function() {
      return buffer_layout_2.s16;
    } });
    Object.defineProperty(exports2, "u32", { enumerable: true, get: function() {
      return buffer_layout_2.u32;
    } });
    Object.defineProperty(exports2, "i32", { enumerable: true, get: function() {
      return buffer_layout_2.s32;
    } });
    Object.defineProperty(exports2, "f32", { enumerable: true, get: function() {
      return buffer_layout_2.f32;
    } });
    Object.defineProperty(exports2, "f64", { enumerable: true, get: function() {
      return buffer_layout_2.f64;
    } });
    Object.defineProperty(exports2, "struct", { enumerable: true, get: function() {
      return buffer_layout_2.struct;
    } });
    var BNLayout = class extends buffer_layout_1.Layout {
      constructor(span, signed, property) {
        super(span, property);
        this.blob = buffer_layout_1.blob(span);
        this.signed = signed;
      }
      decode(b, offset2 = 0) {
        const num = new bn_js_1.default(this.blob.decode(b, offset2), 10, "le");
        if (this.signed) {
          return num.fromTwos(this.span * 8).clone();
        }
        return num;
      }
      encode(src, b, offset2 = 0) {
        if (this.signed) {
          src = src.toTwos(this.span * 8);
        }
        return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b, offset2);
      }
    };
    function u644(property) {
      return new BNLayout(8, false, property);
    }
    exports2.u64 = u644;
    function i642(property) {
      return new BNLayout(8, true, property);
    }
    exports2.i64 = i642;
    function u1282(property) {
      return new BNLayout(16, false, property);
    }
    exports2.u128 = u1282;
    function i1282(property) {
      return new BNLayout(16, true, property);
    }
    exports2.i128 = i1282;
    var WrappedLayout3 = class extends buffer_layout_1.Layout {
      constructor(layout, decoder, encoder, property) {
        super(layout.span, property);
        this.layout = layout;
        this.decoder = decoder;
        this.encoder = encoder;
      }
      decode(b, offset2) {
        return this.decoder(this.layout.decode(b, offset2));
      }
      encode(src, b, offset2) {
        return this.layout.encode(this.encoder(src), b, offset2);
      }
      getSpan(b, offset2) {
        return this.layout.getSpan(b, offset2);
      }
    };
    function publicKey8(property) {
      return new WrappedLayout3(buffer_layout_1.blob(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);
    }
    exports2.publicKey = publicKey8;
    var OptionLayout = class extends buffer_layout_1.Layout {
      constructor(layout, property) {
        super(-1, property);
        this.layout = layout;
        this.discriminator = buffer_layout_1.u8();
      }
      encode(src, b, offset2 = 0) {
        if (src === null || src === void 0) {
          return this.discriminator.encode(0, b, offset2);
        }
        this.discriminator.encode(1, b, offset2);
        return this.layout.encode(src, b, offset2 + 1) + 1;
      }
      decode(b, offset2 = 0) {
        const discriminator = this.discriminator.decode(b, offset2);
        if (discriminator === 0) {
          return null;
        } else if (discriminator === 1) {
          return this.layout.decode(b, offset2 + 1);
        }
        throw new Error("Invalid option " + this.property);
      }
      getSpan(b, offset2 = 0) {
        const discriminator = this.discriminator.decode(b, offset2);
        if (discriminator === 0) {
          return 1;
        } else if (discriminator === 1) {
          return this.layout.getSpan(b, offset2 + 1) + 1;
        }
        throw new Error("Invalid option " + this.property);
      }
    };
    function option3(layout, property) {
      return new OptionLayout(layout, property);
    }
    exports2.option = option3;
    function bool3(property) {
      return new WrappedLayout3(buffer_layout_1.u8(), decodeBool2, encodeBool2, property);
    }
    exports2.bool = bool3;
    function decodeBool2(value) {
      if (value === 0) {
        return false;
      } else if (value === 1) {
        return true;
      }
      throw new Error("Invalid bool: " + value);
    }
    function encodeBool2(value) {
      return value ? 1 : 0;
    }
    function vec2(elementLayout, property) {
      const length = buffer_layout_1.u32("length");
      const layout = buffer_layout_1.struct([
        length,
        buffer_layout_1.seq(elementLayout, buffer_layout_1.offset(length, -length.span), "values")
      ]);
      return new WrappedLayout3(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    exports2.vec = vec2;
    function tagged(tag, layout, property) {
      const wrappedLayout = buffer_layout_1.struct([
        u644("tag"),
        layout.replicate("data")
      ]);
      function decodeTag({ tag: receivedTag, data }) {
        if (!receivedTag.eq(tag)) {
          throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
        }
        return data;
      }
      return new WrappedLayout3(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
    }
    exports2.tagged = tagged;
    function vecU83(property) {
      const length = buffer_layout_1.u32("length");
      const layout = buffer_layout_1.struct([
        length,
        buffer_layout_1.blob(buffer_layout_1.offset(length, -length.span), "data")
      ]);
      return new WrappedLayout3(layout, ({ data }) => data, (data) => ({ data }), property);
    }
    exports2.vecU8 = vecU83;
    function str2(property) {
      return new WrappedLayout3(vecU83(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
    }
    exports2.str = str2;
    function rustEnum3(variants, property, discriminant) {
      const unionLayout = buffer_layout_1.union(discriminant !== null && discriminant !== void 0 ? discriminant : buffer_layout_1.u8(), property);
      variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
      return unionLayout;
    }
    exports2.rustEnum = rustEnum3;
    function array3(elementLayout, length, property) {
      const layout = buffer_layout_1.struct([
        buffer_layout_1.seq(elementLayout, length, "values")
      ]);
      return new WrappedLayout3(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    exports2.array = array3;
    var MapEntryLayout = class extends buffer_layout_1.Layout {
      constructor(keyLayout, valueLayout, property) {
        super(keyLayout.span + valueLayout.span, property);
        this.keyLayout = keyLayout;
        this.valueLayout = valueLayout;
      }
      decode(b, offset2) {
        offset2 = offset2 || 0;
        const key = this.keyLayout.decode(b, offset2);
        const value = this.valueLayout.decode(b, offset2 + this.keyLayout.getSpan(b, offset2));
        return [key, value];
      }
      encode(src, b, offset2) {
        offset2 = offset2 || 0;
        const keyBytes = this.keyLayout.encode(src[0], b, offset2);
        const valueBytes = this.valueLayout.encode(src[1], b, offset2 + keyBytes);
        return keyBytes + valueBytes;
      }
      getSpan(b, offset2) {
        return this.keyLayout.getSpan(b, offset2) + this.valueLayout.getSpan(b, offset2);
      }
    };
    function map(keyLayout, valueLayout, property) {
      const length = buffer_layout_1.u32("length");
      const layout = buffer_layout_1.struct([
        length,
        buffer_layout_1.seq(new MapEntryLayout(keyLayout, valueLayout), buffer_layout_1.offset(length, -length.span), "values")
      ]);
      return new WrappedLayout3(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
    }
    exports2.map = map;
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/borsh/idl.js
var import_camelcase, borsh, IdlCoder;
var init_idl = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/borsh/idl.js"() {
    init_define_process_env();
    import_camelcase = __toModule(require_camelcase());
    borsh = __toModule(require_lib());
    init_error();
    IdlCoder = class {
      static fieldLayout(field, types) {
        const fieldName = field.name !== void 0 ? (0, import_camelcase.default)(field.name) : void 0;
        switch (field.type) {
          case "bool": {
            return borsh.bool(fieldName);
          }
          case "u8": {
            return borsh.u8(fieldName);
          }
          case "i8": {
            return borsh.i8(fieldName);
          }
          case "u16": {
            return borsh.u16(fieldName);
          }
          case "i16": {
            return borsh.i16(fieldName);
          }
          case "u32": {
            return borsh.u32(fieldName);
          }
          case "i32": {
            return borsh.i32(fieldName);
          }
          case "f32": {
            return borsh.f32(fieldName);
          }
          case "u64": {
            return borsh.u64(fieldName);
          }
          case "i64": {
            return borsh.i64(fieldName);
          }
          case "f64": {
            return borsh.f64(fieldName);
          }
          case "u128": {
            return borsh.u128(fieldName);
          }
          case "i128": {
            return borsh.i128(fieldName);
          }
          case "bytes": {
            return borsh.vecU8(fieldName);
          }
          case "string": {
            return borsh.str(fieldName);
          }
          case "publicKey": {
            return borsh.publicKey(fieldName);
          }
          default: {
            if ("vec" in field.type) {
              return borsh.vec(IdlCoder.fieldLayout({
                name: void 0,
                type: field.type.vec
              }, types), fieldName);
            } else if ("option" in field.type) {
              return borsh.option(IdlCoder.fieldLayout({
                name: void 0,
                type: field.type.option
              }, types), fieldName);
            } else if ("defined" in field.type) {
              const defined = field.type.defined;
              if (types === void 0) {
                throw new IdlError("User defined types not provided");
              }
              const filtered = types.filter((t) => t.name === defined);
              if (filtered.length !== 1) {
                throw new IdlError(`Type not found: ${JSON.stringify(field)}`);
              }
              return IdlCoder.typeDefLayout(filtered[0], types, fieldName);
            } else if ("array" in field.type) {
              let arrayTy = field.type.array[0];
              let arrayLen = field.type.array[1];
              let innerLayout = IdlCoder.fieldLayout({
                name: void 0,
                type: arrayTy
              }, types);
              return borsh.array(innerLayout, arrayLen, fieldName);
            } else {
              throw new Error(`Not yet implemented: ${field}`);
            }
          }
        }
      }
      static typeDefLayout(typeDef, types = [], name) {
        if (typeDef.type.kind === "struct") {
          const fieldLayouts = typeDef.type.fields.map((field) => {
            const x = IdlCoder.fieldLayout(field, types);
            return x;
          });
          return borsh.struct(fieldLayouts, name);
        } else if (typeDef.type.kind === "enum") {
          let variants = typeDef.type.variants.map((variant) => {
            const name2 = (0, import_camelcase.default)(variant.name);
            if (variant.fields === void 0) {
              return borsh.struct([], name2);
            }
            const fieldLayouts = variant.fields.map((f) => {
              if (!f.hasOwnProperty("name")) {
                throw new Error("Tuple enum variants not yet implemented.");
              }
              return IdlCoder.fieldLayout(f, types);
            });
            return borsh.struct(fieldLayouts, name2);
          });
          if (name !== void 0) {
            return borsh.rustEnum(variants).replicate(name);
          }
          return borsh.rustEnum(variants, name);
        } else {
          throw new Error(`Unknown type kint: ${typeDef}`);
        }
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/borsh/instruction.js
function sentenceCase(field) {
  const result = field.replace(/([A-Z])/g, " $1");
  return result.charAt(0).toUpperCase() + result.slice(1);
}
function sighash(nameSpace, ixName) {
  let name = snakeCase(ixName);
  let preimage = `${nameSpace}:${name}`;
  return import_buffer4.Buffer.from(import_js_sha256.sha256.digest(preimage)).slice(0, 8);
}
var import_bs582, import_buffer4, import_camelcase2, import_js_sha256, borsh2, SIGHASH_STATE_NAMESPACE, SIGHASH_GLOBAL_NAMESPACE, BorshInstructionCoder, InstructionFormatter;
var init_instruction = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/borsh/instruction.js"() {
    init_define_process_env();
    import_bs582 = __toModule(require_bs58());
    import_buffer4 = __toModule(require_buffer());
    import_camelcase2 = __toModule(require_camelcase());
    init_dist4();
    import_js_sha256 = __toModule(require_sha256());
    borsh2 = __toModule(require_lib());
    init_idl();
    SIGHASH_STATE_NAMESPACE = "state";
    SIGHASH_GLOBAL_NAMESPACE = "global";
    BorshInstructionCoder = class {
      constructor(idl) {
        this.idl = idl;
        this.ixLayout = BorshInstructionCoder.parseIxLayout(idl);
        const sighashLayouts = new Map();
        idl.instructions.forEach((ix) => {
          const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);
          sighashLayouts.set(import_bs582.default.encode(sh), {
            layout: this.ixLayout.get(ix.name),
            name: ix.name
          });
        });
        if (idl.state) {
          idl.state.methods.map((ix) => {
            const sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);
            sighashLayouts.set(import_bs582.default.encode(sh), {
              layout: this.ixLayout.get(ix.name),
              name: ix.name
            });
          });
        }
        this.sighashLayouts = sighashLayouts;
      }
      encode(ixName, ix) {
        return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);
      }
      encodeState(ixName, ix) {
        return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);
      }
      _encode(nameSpace, ixName, ix) {
        const buffer = import_buffer4.Buffer.alloc(1e3);
        const methodName = (0, import_camelcase2.default)(ixName);
        const layout = this.ixLayout.get(methodName);
        if (!layout) {
          throw new Error(`Unknown method: ${methodName}`);
        }
        const len = layout.encode(ix, buffer);
        const data = buffer.slice(0, len);
        return import_buffer4.Buffer.concat([sighash(nameSpace, ixName), data]);
      }
      static parseIxLayout(idl) {
        const stateMethods = idl.state ? idl.state.methods : [];
        const ixLayouts = stateMethods.map((m) => {
          let fieldLayouts = m.args.map((arg) => {
            var _a2, _b;
            return IdlCoder.fieldLayout(arg, Array.from([...(_a2 = idl.accounts) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
          });
          const name = (0, import_camelcase2.default)(m.name);
          return [name, borsh2.struct(fieldLayouts, name)];
        }).concat(idl.instructions.map((ix) => {
          let fieldLayouts = ix.args.map((arg) => {
            var _a2, _b;
            return IdlCoder.fieldLayout(arg, Array.from([...(_a2 = idl.accounts) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
          });
          const name = (0, import_camelcase2.default)(ix.name);
          return [name, borsh2.struct(fieldLayouts, name)];
        }));
        return new Map(ixLayouts);
      }
      decode(ix, encoding = "hex") {
        if (typeof ix === "string") {
          ix = encoding === "hex" ? import_buffer4.Buffer.from(ix, "hex") : import_bs582.default.decode(ix);
        }
        let sighash2 = import_bs582.default.encode(ix.slice(0, 8));
        let data = ix.slice(8);
        const decoder = this.sighashLayouts.get(sighash2);
        if (!decoder) {
          return null;
        }
        return {
          data: decoder.layout.decode(data),
          name: decoder.name
        };
      }
      format(ix, accountMetas) {
        return InstructionFormatter.format(ix, accountMetas, this.idl);
      }
    };
    InstructionFormatter = class {
      static format(ix, accountMetas, idl) {
        const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];
        if (idlIx === void 0) {
          console.error("Invalid instruction given");
          return null;
        }
        const args = idlIx.args.map((idlField) => {
          return {
            name: idlField.name,
            type: InstructionFormatter.formatIdlType(idlField.type),
            data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)
          };
        });
        const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);
        const accounts = accountMetas.map((meta, idx) => {
          if (idx < flatIdlAccounts.length) {
            return {
              name: flatIdlAccounts[idx].name,
              ...meta
            };
          } else {
            return {
              name: void 0,
              ...meta
            };
          }
        });
        return {
          args,
          accounts
        };
      }
      static formatIdlType(idlType) {
        if (typeof idlType === "string") {
          return idlType;
        }
        if ("vec" in idlType) {
          return `Vec<${this.formatIdlType(idlType.vec)}>`;
        }
        if ("option" in idlType) {
          return `Option<${this.formatIdlType(idlType.option)}>`;
        }
        if ("defined" in idlType) {
          return idlType.defined;
        }
        if ("array" in idlType) {
          return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;
        }
        throw new Error(`Unknown IDL type: ${idlType}`);
      }
      static formatIdlData(idlField, data, types) {
        if (typeof idlField.type === "string") {
          return data.toString();
        }
        if (idlField.type.hasOwnProperty("vec")) {
          return "[" + data.map((d) => this.formatIdlData({ name: "", type: idlField.type.vec }, d)).join(", ") + "]";
        }
        if (idlField.type.hasOwnProperty("option")) {
          return data === null ? "null" : this.formatIdlData({ name: "", type: idlField.type.option }, data, types);
        }
        if (idlField.type.hasOwnProperty("defined")) {
          if (types === void 0) {
            throw new Error("User defined types not provided");
          }
          const filtered = types.filter((t) => t.name === idlField.type.defined);
          if (filtered.length !== 1) {
            throw new Error(`Type not found: ${idlField.type.defined}`);
          }
          return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);
        }
        return "unknown";
      }
      static formatIdlDataDefined(typeDef, data, types) {
        if (typeDef.type.kind === "struct") {
          const struct9 = typeDef.type;
          const fields = Object.keys(data).map((k) => {
            const f = struct9.fields.filter((f2) => f2.name === k)[0];
            if (f === void 0) {
              throw new Error("Unable to find type");
            }
            return k + ": " + InstructionFormatter.formatIdlData(f, data[k], types);
          }).join(", ");
          return "{ " + fields + " }";
        } else {
          if (typeDef.type.variants.length === 0) {
            return "{}";
          }
          if (typeDef.type.variants[0].name) {
            const variants = typeDef.type.variants;
            const variant = Object.keys(data)[0];
            const enumType = data[variant];
            const namedFields = Object.keys(enumType).map((f) => {
              var _a2;
              const fieldData = enumType[f];
              const idlField = (_a2 = variants[variant]) === null || _a2 === void 0 ? void 0 : _a2.filter((v) => v.name === f)[0];
              if (idlField === void 0) {
                throw new Error("Unable to find variant");
              }
              return f + ": " + InstructionFormatter.formatIdlData(idlField, fieldData, types);
            }).join(", ");
            const variantName = (0, import_camelcase2.default)(variant, { pascalCase: true });
            if (namedFields.length === 0) {
              return variantName;
            }
            return `${variantName} { ${namedFields} }`;
          } else {
            return "Tuple formatting not yet implemented";
          }
        }
      }
      static flattenIdlAccounts(accounts, prefix) {
        return accounts.map((account) => {
          const accName = sentenceCase(account.name);
          if (account.hasOwnProperty("accounts")) {
            const newPrefix = prefix ? `${prefix} > ${accName}` : accName;
            return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);
          } else {
            return {
              ...account,
              name: prefix ? `${prefix} > ${accName}` : accName
            };
          }
        }).flat();
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/common.js
function accountSize(idl, idlAccount) {
  if (idlAccount.type.kind === "enum") {
    let variantSizes = idlAccount.type.variants.map((variant) => {
      if (variant.fields === void 0) {
        return 0;
      }
      return variant.fields.map((f) => {
        if (!(typeof f === "object" && "name" in f)) {
          throw new Error("Tuple enum variants not yet implemented.");
        }
        return typeSize(idl, f.type);
      }).reduce((a, b) => a + b);
    });
    return Math.max(...variantSizes) + 1;
  }
  if (idlAccount.type.fields === void 0) {
    return 0;
  }
  return idlAccount.type.fields.map((f) => typeSize(idl, f.type)).reduce((a, b) => a + b, 0);
}
function typeSize(idl, ty) {
  var _a2, _b;
  switch (ty) {
    case "bool":
      return 1;
    case "u8":
      return 1;
    case "i8":
      return 1;
    case "i16":
      return 2;
    case "u16":
      return 2;
    case "u32":
      return 4;
    case "i32":
      return 4;
    case "f32":
      return 4;
    case "u64":
      return 8;
    case "i64":
      return 8;
    case "f64":
      return 8;
    case "u128":
      return 16;
    case "i128":
      return 16;
    case "bytes":
      return 1;
    case "string":
      return 1;
    case "publicKey":
      return 32;
    default:
      if ("vec" in ty) {
        return 1;
      }
      if ("option" in ty) {
        return 1 + typeSize(idl, ty.option);
      }
      if ("coption" in ty) {
        return 4 + typeSize(idl, ty.coption);
      }
      if ("defined" in ty) {
        const filtered = (_b = (_a2 = idl.types) === null || _a2 === void 0 ? void 0 : _a2.filter((t) => t.name === ty.defined)) !== null && _b !== void 0 ? _b : [];
        if (filtered.length !== 1) {
          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);
        }
        let typeDef = filtered[0];
        return accountSize(idl, typeDef);
      }
      if ("array" in ty) {
        let arrayTy = ty.array[0];
        let arraySize = ty.array[1];
        return typeSize(idl, arrayTy) * arraySize;
      }
      throw new Error(`Invalid type ${JSON.stringify(ty)}`);
  }
}
var init_common3 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/common.js"() {
    init_define_process_env();
    init_error();
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/borsh/accounts.js
var import_bs583, import_buffer5, import_camelcase3, import_js_sha2562, ACCOUNT_DISCRIMINATOR_SIZE, BorshAccountsCoder;
var init_accounts = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/borsh/accounts.js"() {
    init_define_process_env();
    import_bs583 = __toModule(require_bs58());
    import_buffer5 = __toModule(require_buffer());
    import_camelcase3 = __toModule(require_camelcase());
    import_js_sha2562 = __toModule(require_sha256());
    init_idl();
    init_common3();
    ACCOUNT_DISCRIMINATOR_SIZE = 8;
    BorshAccountsCoder = class {
      constructor(idl) {
        if (idl.accounts === void 0) {
          this.accountLayouts = new Map();
          return;
        }
        const layouts = idl.accounts.map((acc) => {
          return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
        });
        this.accountLayouts = new Map(layouts);
        this.idl = idl;
      }
      async encode(accountName, account) {
        const buffer = import_buffer5.Buffer.alloc(1e3);
        const layout = this.accountLayouts.get(accountName);
        if (!layout) {
          throw new Error(`Unknown account: ${accountName}`);
        }
        const len = layout.encode(account, buffer);
        let accountData = buffer.slice(0, len);
        let discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
        return import_buffer5.Buffer.concat([discriminator, accountData]);
      }
      decode(accountName, data) {
        const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
        if (discriminator.compare(data.slice(0, 8))) {
          throw new Error("Invalid account discriminator");
        }
        return this.decodeUnchecked(accountName, data);
      }
      decodeUnchecked(accountName, ix) {
        const data = ix.slice(ACCOUNT_DISCRIMINATOR_SIZE);
        const layout = this.accountLayouts.get(accountName);
        if (!layout) {
          throw new Error(`Unknown account: ${accountName}`);
        }
        return layout.decode(data);
      }
      memcmp(accountName, appendData) {
        const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
        return {
          offset: 0,
          bytes: import_bs583.default.encode(appendData ? import_buffer5.Buffer.concat([discriminator, appendData]) : discriminator)
        };
      }
      size(idlAccount) {
        var _a2;
        return ACCOUNT_DISCRIMINATOR_SIZE + ((_a2 = accountSize(this.idl, idlAccount)) !== null && _a2 !== void 0 ? _a2 : 0);
      }
      static accountDiscriminator(name) {
        return import_buffer5.Buffer.from(import_js_sha2562.sha256.digest(`account:${(0, import_camelcase3.default)(name, { pascalCase: true })}`)).slice(0, ACCOUNT_DISCRIMINATOR_SIZE);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/borsh/event.js
function eventDiscriminator(name) {
  return import_buffer6.Buffer.from(import_js_sha2563.sha256.digest(`event:${name}`)).slice(0, 8);
}
var import_buffer6, base642, import_js_sha2563, BorshEventCoder;
var init_event = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/borsh/event.js"() {
    init_define_process_env();
    import_buffer6 = __toModule(require_buffer());
    base642 = __toModule(require_base64_js());
    import_js_sha2563 = __toModule(require_sha256());
    init_idl();
    BorshEventCoder = class {
      constructor(idl) {
        if (idl.events === void 0) {
          this.layouts = new Map();
          return;
        }
        const layouts = idl.events.map((event) => {
          let eventTypeDef = {
            name: event.name,
            type: {
              kind: "struct",
              fields: event.fields.map((f) => {
                return { name: f.name, type: f.type };
              })
            }
          };
          return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];
        });
        this.layouts = new Map(layouts);
        this.discriminators = new Map(idl.events === void 0 ? [] : idl.events.map((e) => [
          base642.fromByteArray(eventDiscriminator(e.name)),
          e.name
        ]));
      }
      decode(log) {
        let logArr;
        try {
          logArr = import_buffer6.Buffer.from(base642.toByteArray(log));
        } catch (e) {
          return null;
        }
        const disc = base642.fromByteArray(logArr.slice(0, 8));
        const eventName = this.discriminators.get(disc);
        if (eventName === void 0) {
          return null;
        }
        const layout = this.layouts.get(eventName);
        if (!layout) {
          throw new Error(`Unknown event: ${eventName}`);
        }
        const data = layout.decode(logArr.slice(8));
        return { data, name: eventName };
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/borsh/state.js
async function stateDiscriminator(name) {
  let ns = isSet("anchor-deprecated-state") ? "account" : "state";
  return import_buffer7.Buffer.from(import_js_sha2564.sha256.digest(`${ns}:${name}`)).slice(0, 8);
}
var import_buffer7, import_js_sha2564, BorshStateCoder;
var init_state = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/borsh/state.js"() {
    init_define_process_env();
    import_buffer7 = __toModule(require_buffer());
    import_js_sha2564 = __toModule(require_sha256());
    init_idl();
    init_features();
    BorshStateCoder = class {
      constructor(idl) {
        if (idl.state === void 0) {
          throw new Error("Idl state not defined.");
        }
        this.layout = IdlCoder.typeDefLayout(idl.state.struct, idl.types);
      }
      async encode(name, account) {
        const buffer = import_buffer7.Buffer.alloc(1e3);
        const len = this.layout.encode(account, buffer);
        const disc = await stateDiscriminator(name);
        const accData = buffer.slice(0, len);
        return import_buffer7.Buffer.concat([disc, accData]);
      }
      decode(ix) {
        const data = ix.slice(8);
        return this.layout.decode(data);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/borsh/types.js
var import_buffer8, BorshTypesCoder;
var init_types = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/borsh/types.js"() {
    init_define_process_env();
    import_buffer8 = __toModule(require_buffer());
    init_idl();
    BorshTypesCoder = class {
      constructor(idl) {
        if (idl.types === void 0) {
          this.typeLayouts = new Map();
          return;
        }
        const layouts = idl.types.map((acc) => {
          return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
        });
        this.typeLayouts = new Map(layouts);
        this.idl = idl;
      }
      encode(typeName, type2) {
        const buffer = import_buffer8.Buffer.alloc(1e3);
        const layout = this.typeLayouts.get(typeName);
        if (!layout) {
          throw new Error(`Unknown type: ${typeName}`);
        }
        const len = layout.encode(type2, buffer);
        return buffer.slice(0, len);
      }
      decode(typeName, typeData) {
        const layout = this.typeLayouts.get(typeName);
        if (!layout) {
          throw new Error(`Unknown type: ${typeName}`);
        }
        return layout.decode(typeData);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/borsh/index.js
var BorshCoder;
var init_borsh = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/borsh/index.js"() {
    init_define_process_env();
    init_instruction();
    init_accounts();
    init_event();
    init_state();
    init_types();
    init_instruction();
    init_accounts();
    init_event();
    init_state();
    BorshCoder = class {
      constructor(idl) {
        this.instruction = new BorshInstructionCoder(idl);
        this.accounts = new BorshAccountsCoder(idl);
        this.events = new BorshEventCoder(idl);
        if (idl.state) {
          this.state = new BorshStateCoder(idl);
        }
        this.types = new BorshTypesCoder(idl);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/spl-token/instruction.js
function encodeInitializeMint({ decimals, mintAuthority, freezeAuthority }) {
  return encodeData({
    initializeMint: {
      decimals,
      mintAuthority: mintAuthority.toBuffer(),
      freezeAuthorityOption: !!freezeAuthority,
      freezeAuthority: (freezeAuthority || PublicKey.default).toBuffer()
    }
  });
}
function encodeInitializeAccount(_ix) {
  return encodeData({
    initializeAccount: {}
  });
}
function encodeInitializeMultisig({ m }) {
  return encodeData({
    initializeMultisig: {
      m
    }
  });
}
function encodeTransfer({ amount }) {
  return encodeData({
    transfer: { amount }
  });
}
function encodeApprove({ amount }) {
  return encodeData({
    approve: { amount }
  });
}
function encodeRevoke(_ix) {
  return encodeData({
    revoke: {}
  });
}
function encodeSetAuthority({ authorityType, newAuthority }) {
  return encodeData({
    setAuthority: { authorityType, newAuthority }
  });
}
function encodeMintTo({ amount }) {
  return encodeData({
    mintTo: { amount }
  });
}
function encodeBurn({ amount }) {
  return encodeData({
    burn: { amount }
  });
}
function encodeCloseAccount(_) {
  return encodeData({
    closeAccount: {}
  });
}
function encodeFreezeAccount(_) {
  return encodeData({
    freezeAccount: {}
  });
}
function encodeThawAccount(_) {
  return encodeData({
    thawAccount: {}
  });
}
function encodeTransferChecked({ amount, decimals }) {
  return encodeData({
    transferChecked: { amount, decimals }
  });
}
function encodeApproveChecked({ amount, decimals }) {
  return encodeData({
    approveChecked: { amount, decimals }
  });
}
function encodeMintToChecked({ amount, decimals }) {
  return encodeData({
    mintToChecked: { amount, decimals }
  });
}
function encodeBurnChecked({ amount, decimals }) {
  return encodeData({
    burnChecked: { amount, decimals }
  });
}
function encodeInitializeAccount2({ authority }) {
  return encodeData({
    initilaizeAccount2: { authority }
  });
}
function encodeSyncNative(_) {
  return encodeData({
    syncNative: {}
  });
}
function encodeInitializeAccount3({ authority }) {
  return encodeData({
    initializeAccount3: { authority }
  });
}
function encodeInitializeMultisig2({ m }) {
  return encodeData({
    initializeMultisig2: { m }
  });
}
function encodeInitializeMint2({ decimals, mintAuthority, freezeAuthority }) {
  return encodeData({
    encodeInitializeMint2: { decimals, mintAuthority, freezeAuthority }
  });
}
function publicKey2(property) {
  return BufferLayout.blob(32, property);
}
function encodeData(instruction) {
  let b = Buffer.alloc(instructionMaxSpan);
  let span = LAYOUT.encode(instruction, b);
  return b.slice(0, span);
}
var BufferLayout, import_camelcase4, SplTokenInstructionCoder, LAYOUT, instructionMaxSpan;
var init_instruction2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/spl-token/instruction.js"() {
    init_define_process_env();
    BufferLayout = __toModule(require_Layout());
    import_camelcase4 = __toModule(require_camelcase());
    init_index_browser_esm();
    SplTokenInstructionCoder = class {
      constructor(_) {
      }
      encode(ixName, ix) {
        switch ((0, import_camelcase4.default)(ixName)) {
          case "initializeMint": {
            return encodeInitializeMint(ix);
          }
          case "initializeAccount": {
            return encodeInitializeAccount(ix);
          }
          case "initializeMultisig": {
            return encodeInitializeMultisig(ix);
          }
          case "transfer": {
            return encodeTransfer(ix);
          }
          case "approve": {
            return encodeApprove(ix);
          }
          case "revoke": {
            return encodeRevoke(ix);
          }
          case "setAuthority": {
            return encodeSetAuthority(ix);
          }
          case "mintTo": {
            return encodeMintTo(ix);
          }
          case "burn": {
            return encodeBurn(ix);
          }
          case "closeAccount": {
            return encodeCloseAccount(ix);
          }
          case "freezeAccount": {
            return encodeFreezeAccount(ix);
          }
          case "thawAccount": {
            return encodeThawAccount(ix);
          }
          case "transferChecked": {
            return encodeTransferChecked(ix);
          }
          case "approvedChecked": {
            return encodeApproveChecked(ix);
          }
          case "mintToChecked": {
            return encodeMintToChecked(ix);
          }
          case "burnChecked": {
            return encodeBurnChecked(ix);
          }
          case "intializeAccount2": {
            return encodeInitializeAccount2(ix);
          }
          case "syncNative": {
            return encodeSyncNative(ix);
          }
          case "initializeAccount3": {
            return encodeInitializeAccount3(ix);
          }
          case "initializeMultisig2": {
            return encodeInitializeMultisig2(ix);
          }
          case "initializeMint2": {
            return encodeInitializeMint2(ix);
          }
          default: {
            throw new Error(`Invalid instruction: ${ixName}`);
          }
        }
      }
      encodeState(_ixName, _ix) {
        throw new Error("SPL token does not have state");
      }
    };
    LAYOUT = BufferLayout.union(BufferLayout.u8("instruction"));
    LAYOUT.addVariant(0, BufferLayout.struct([
      BufferLayout.u8("decimals"),
      BufferLayout.blob(32, "mintAuthority"),
      BufferLayout.u8("freezeAuthorityOption"),
      publicKey2("freezeAuthority")
    ]), "initializeMint");
    LAYOUT.addVariant(1, BufferLayout.struct([]), "initializeAccount");
    LAYOUT.addVariant(2, BufferLayout.struct([BufferLayout.u8("m")]), "initializeMultisig");
    LAYOUT.addVariant(3, BufferLayout.struct([BufferLayout.nu64("amount")]), "transfer");
    LAYOUT.addVariant(4, BufferLayout.struct([BufferLayout.nu64("amount")]), "approve");
    LAYOUT.addVariant(5, BufferLayout.struct([]), "revoke");
    LAYOUT.addVariant(6, BufferLayout.struct([
      BufferLayout.u8("authorityType"),
      BufferLayout.u8("newAuthorityOption"),
      publicKey2("newAuthority")
    ]), "setAuthority");
    LAYOUT.addVariant(7, BufferLayout.struct([BufferLayout.nu64("amount")]), "mintTo");
    LAYOUT.addVariant(8, BufferLayout.struct([BufferLayout.nu64("amount")]), "burn");
    LAYOUT.addVariant(9, BufferLayout.struct([]), "closeAccount");
    LAYOUT.addVariant(10, BufferLayout.struct([]), "freezeAccount");
    LAYOUT.addVariant(11, BufferLayout.struct([]), "thawAccount");
    LAYOUT.addVariant(12, BufferLayout.struct([
      BufferLayout.nu64("amount"),
      BufferLayout.u8("decimals")
    ]), "transferChecked");
    LAYOUT.addVariant(13, BufferLayout.struct([
      BufferLayout.nu64("amount"),
      BufferLayout.u8("decimals")
    ]), "approvedChecked");
    LAYOUT.addVariant(14, BufferLayout.struct([
      BufferLayout.nu64("amount"),
      BufferLayout.u8("decimals")
    ]), "mintToChecked");
    LAYOUT.addVariant(15, BufferLayout.struct([
      BufferLayout.nu64("amount"),
      BufferLayout.u8("decimals")
    ]), "burnedChecked");
    LAYOUT.addVariant(16, BufferLayout.struct([publicKey2("authority")]), "InitializeAccount2");
    LAYOUT.addVariant(17, BufferLayout.struct([]), "syncNative");
    LAYOUT.addVariant(18, BufferLayout.struct([publicKey2("authority")]), "initializeAccount3");
    LAYOUT.addVariant(19, BufferLayout.struct([BufferLayout.u8("m")]), "initializeMultisig2");
    LAYOUT.addVariant(20, BufferLayout.struct([
      BufferLayout.u8("decimals"),
      publicKey2("mintAuthority"),
      BufferLayout.u8("freezeAuthorityOption"),
      publicKey2("freezeAuthority")
    ]), "initializeMint2");
    instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r) => r.span));
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/spl-token/state.js
var SplTokenStateCoder;
var init_state2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/spl-token/state.js"() {
    init_define_process_env();
    SplTokenStateCoder = class {
      constructor(_idl) {
      }
      encode(_name, _account) {
        throw new Error("SPL token does not have state");
      }
      decode(_ix) {
        throw new Error("SPL token does not have state");
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/spl-token/buffer-layout.js
function uint64(property) {
  return new WrappedLayout(BufferLayout2.blob(8), (b) => u642.fromBuffer(b), (n) => n.toBuffer(), property);
}
function bool2(property) {
  return new WrappedLayout(BufferLayout2.u8(), decodeBool, encodeBool, property);
}
function publicKey3(property) {
  return new WrappedLayout(BufferLayout2.blob(32), (b) => new PublicKey(b), (key) => key.toBuffer(), property);
}
function coption(layout, property) {
  return new COptionLayout(layout, property);
}
function decodeBool(value) {
  if (value === 0) {
    return false;
  } else if (value === 1) {
    return true;
  }
  throw new Error("Invalid bool: " + value);
}
function encodeBool(value) {
  return value ? 1 : 0;
}
var import_bn, BufferLayout2, import_buffer_layout, WrappedLayout, COptionLayout, u642;
var init_buffer_layout = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/spl-token/buffer-layout.js"() {
    init_define_process_env();
    import_bn = __toModule(require_bn());
    BufferLayout2 = __toModule(require_Layout());
    import_buffer_layout = __toModule(require_Layout());
    init_index_browser_esm();
    WrappedLayout = class extends import_buffer_layout.Layout {
      constructor(layout, decoder, encoder, property) {
        super(layout.span, property);
        this.layout = layout;
        this.decoder = decoder;
        this.encoder = encoder;
      }
      decode(b, offset2) {
        return this.decoder(this.layout.decode(b, offset2));
      }
      encode(src, b, offset2) {
        return this.layout.encode(this.encoder(src), b, offset2);
      }
      getSpan(b, offset2) {
        return this.layout.getSpan(b, offset2);
      }
    };
    COptionLayout = class extends import_buffer_layout.Layout {
      constructor(layout, property) {
        super(-1, property);
        this.layout = layout;
        this.discriminator = BufferLayout2.u32();
      }
      encode(src, b, offset2 = 0) {
        if (src === null || src === void 0) {
          return this.layout.span + this.discriminator.encode(0, b, offset2);
        }
        this.discriminator.encode(1, b, offset2);
        return this.layout.encode(src, b, offset2 + 4) + 4;
      }
      decode(b, offset2 = 0) {
        const discriminator = this.discriminator.decode(b, offset2);
        if (discriminator === 0) {
          return null;
        } else if (discriminator === 1) {
          return this.layout.decode(b, offset2 + 4);
        }
        throw new Error("Invalid coption " + this.layout.property);
      }
      getSpan(b, offset2 = 0) {
        return this.layout.getSpan(b, offset2 + 4) + 4;
      }
    };
    u642 = class extends import_bn.default {
      toBuffer() {
        const a = super.toArray().reverse();
        const b = Buffer.from(a);
        if (b.length === 8) {
          return b;
        }
        if (b.length >= 8) {
          throw new Error("u64 too large");
        }
        const zeroPad = Buffer.alloc(8);
        b.copy(zeroPad);
        return zeroPad;
      }
      static fromBuffer(buffer) {
        if (buffer.length !== 8) {
          throw new Error(`Invalid buffer length: ${buffer.length}`);
        }
        return new u642([...buffer].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""), 16);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/spl-token/accounts.js
function decodeMintAccount(ix) {
  return MINT_ACCOUNT_LAYOUT.decode(ix);
}
function decodeTokenAccount(ix) {
  return TOKEN_ACCOUNT_LAYOUT.decode(ix);
}
var BufferLayout3, SplTokenAccountsCoder, MINT_ACCOUNT_LAYOUT, TOKEN_ACCOUNT_LAYOUT;
var init_accounts2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/spl-token/accounts.js"() {
    init_define_process_env();
    BufferLayout3 = __toModule(require_Layout());
    init_buffer_layout();
    init_common3();
    SplTokenAccountsCoder = class {
      constructor(idl) {
        this.idl = idl;
      }
      async encode(accountName, account) {
        switch (accountName) {
          case "token": {
            const buffer = Buffer.alloc(165);
            const len = TOKEN_ACCOUNT_LAYOUT.encode(account, buffer);
            return buffer.slice(0, len);
          }
          case "mint": {
            const buffer = Buffer.alloc(82);
            const len = MINT_ACCOUNT_LAYOUT.encode(account, buffer);
            return buffer.slice(0, len);
          }
          default: {
            throw new Error(`Invalid account name: ${accountName}`);
          }
        }
      }
      decode(accountName, ix) {
        return this.decodeUnchecked(accountName, ix);
      }
      decodeUnchecked(accountName, ix) {
        switch (accountName) {
          case "token": {
            return decodeTokenAccount(ix);
          }
          case "mint": {
            return decodeMintAccount(ix);
          }
          default: {
            throw new Error(`Invalid account name: ${accountName}`);
          }
        }
      }
      memcmp(accountName, _appendData) {
        switch (accountName) {
          case "token": {
            return {
              dataSize: 165
            };
          }
          case "mint": {
            return {
              dataSize: 82
            };
          }
          default: {
            throw new Error(`Invalid account name: ${accountName}`);
          }
        }
      }
      size(idlAccount) {
        var _a2;
        return (_a2 = accountSize(this.idl, idlAccount)) !== null && _a2 !== void 0 ? _a2 : 0;
      }
    };
    MINT_ACCOUNT_LAYOUT = BufferLayout3.struct([
      coption(publicKey3(), "mintAuthority"),
      uint64("supply"),
      BufferLayout3.u8("decimals"),
      bool2("isInitialized"),
      coption(publicKey3(), "freezeAuthority")
    ]);
    TOKEN_ACCOUNT_LAYOUT = BufferLayout3.struct([
      publicKey3("mint"),
      publicKey3("authority"),
      uint64("amount"),
      coption(publicKey3(), "delegate"),
      BufferLayout3.u8("state"),
      coption(uint64(), "isNative"),
      uint64("delegatedAmount"),
      coption(publicKey3(), "closeAuthority")
    ]);
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/spl-token/events.js
var SplTokenEventsCoder;
var init_events = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/spl-token/events.js"() {
    init_define_process_env();
    SplTokenEventsCoder = class {
      constructor(_idl) {
      }
      decode(_log) {
        throw new Error("SPL token program does not have events");
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/spl-token/types.js
var SplTokenTypesCoder;
var init_types2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/spl-token/types.js"() {
    init_define_process_env();
    SplTokenTypesCoder = class {
      constructor(_idl) {
      }
      encode(_name, _type) {
        throw new Error("SPL token does not have user-defined types");
      }
      decode(_name, _typeData) {
        throw new Error("SPL token does not have user-defined types");
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/spl-token/index.js
var SplTokenCoder;
var init_spl_token = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/spl-token/index.js"() {
    init_define_process_env();
    init_instruction2();
    init_state2();
    init_accounts2();
    init_events();
    init_types2();
    SplTokenCoder = class {
      constructor(idl) {
        this.instruction = new SplTokenInstructionCoder(idl);
        this.accounts = new SplTokenAccountsCoder(idl);
        this.events = new SplTokenEventsCoder(idl);
        this.state = new SplTokenStateCoder(idl);
        this.types = new SplTokenTypesCoder(idl);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/system/instruction.js
function rustStringLayout(property) {
  return new RustStringLayout(property);
}
function publicKey4(property) {
  return BufferLayout4.blob(32, property);
}
function encodeCreateAccount({ lamports, space, owner }) {
  return encodeData2({
    createAccount: { lamports, space, owner: owner.toBuffer() }
  });
}
function encodeAssign({ owner }) {
  return encodeData2({
    assign: { owner: owner.toBuffer() }
  });
}
function encodeTransfer2({ lamports }) {
  return encodeData2({
    transfer: { lamports }
  });
}
function encodeCreateAccountWithSeed({ base, seed: seed2, lamports, space, owner }) {
  return encodeData2({
    createAccountWithSeed: {
      base: base.toBuffer(),
      seed: seed2,
      lamports,
      space,
      owner: owner.toBuffer()
    }
  }, LAYOUT2.getVariant(3).span + seed2.length);
}
function encodeInitializeNonceAccount({ authorized }) {
  return encodeData2({
    initializeNonceAccount: { authorized: authorized.toBuffer() }
  });
}
function encodeAdvanceNonceAccount({ authorized }) {
  return encodeData2({
    advanceNonceAccount: { authorized: authorized.toBuffer() }
  });
}
function encodeWithdrawNonceAccount({ lamports }) {
  return encodeData2({
    withdrawNonceAccount: { lamports }
  });
}
function encodeAuthorizeNonceAccount({ authorized }) {
  return encodeData2({
    authorizeNonceAccount: { authorized: authorized.toBuffer() }
  });
}
function encodeAllocate({ space }) {
  return encodeData2({
    allocate: { space }
  });
}
function encodeAllocateWithSeed({ base, seed: seed2, space, owner }) {
  return encodeData2({
    allocateWithSeed: {
      base: base.toBuffer(),
      seed: seed2,
      space,
      owner: owner.toBuffer()
    }
  }, LAYOUT2.getVariant(9).span + seed2.length);
}
function encodeAssignWithSeed({ base, seed: seed2, owner }) {
  return encodeData2({
    assignWithSeed: {
      base: base.toBuffer(),
      seed: seed2,
      owner: owner.toBuffer()
    }
  }, LAYOUT2.getVariant(10).span + seed2.length);
}
function encodeTransferWithSeed({ lamports, seed: seed2, owner }) {
  return encodeData2({
    transferWithSeed: {
      lamports,
      seed: seed2,
      owner: owner.toBuffer()
    }
  }, LAYOUT2.getVariant(11).span + seed2.length);
}
function encodeData2(instruction, maxSpan) {
  const b = Buffer.alloc(maxSpan !== null && maxSpan !== void 0 ? maxSpan : instructionMaxSpan2);
  const span = LAYOUT2.encode(instruction, b);
  if (maxSpan === void 0) {
    return b.slice(0, span);
  }
  return b;
}
var import_bn2, BufferLayout4, import_camelcase5, SystemInstructionCoder, RustStringLayout, LAYOUT2, instructionMaxSpan2;
var init_instruction3 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/system/instruction.js"() {
    init_define_process_env();
    import_bn2 = __toModule(require_bn());
    BufferLayout4 = __toModule(require_Layout());
    import_camelcase5 = __toModule(require_camelcase());
    SystemInstructionCoder = class {
      constructor(_) {
      }
      encode(ixName, ix) {
        switch ((0, import_camelcase5.default)(ixName)) {
          case "createAccount": {
            return encodeCreateAccount(ix);
          }
          case "assign": {
            return encodeAssign(ix);
          }
          case "transfer": {
            return encodeTransfer2(ix);
          }
          case "createAccountWithSeed": {
            return encodeCreateAccountWithSeed(ix);
          }
          case "advanceNonceAccount": {
            return encodeAdvanceNonceAccount(ix);
          }
          case "withdrawNonceAccount": {
            return encodeWithdrawNonceAccount(ix);
          }
          case "initializeNonceAccount": {
            return encodeInitializeNonceAccount(ix);
          }
          case "authorizeNonceAccount": {
            return encodeAuthorizeNonceAccount(ix);
          }
          case "allocate": {
            return encodeAllocate(ix);
          }
          case "allocateWithSeed": {
            return encodeAllocateWithSeed(ix);
          }
          case "assignWithSeed": {
            return encodeAssignWithSeed(ix);
          }
          case "transferWithSeed": {
            return encodeTransferWithSeed(ix);
          }
          default: {
            throw new Error(`Invalid instruction: ${ixName}`);
          }
        }
      }
      encodeState(_ixName, _ix) {
        throw new Error("System does not have state");
      }
    };
    RustStringLayout = class extends BufferLayout4.Layout {
      constructor(property) {
        super(-1, property);
        this.property = property;
        this.layout = BufferLayout4.struct([
          BufferLayout4.u32("length"),
          BufferLayout4.u32("lengthPadding"),
          BufferLayout4.blob(BufferLayout4.offset(BufferLayout4.u32(), -8), "chars")
        ], this.property);
      }
      encode(src, b, offset2 = 0) {
        if (src === null || src === void 0) {
          return this.layout.span;
        }
        const data = {
          chars: Buffer.from(src, "utf8")
        };
        return this.layout.encode(data, b, offset2);
      }
      decode(b, offset2 = 0) {
        const data = this.layout.decode(b, offset2);
        return data["chars"].toString();
      }
      getSpan(b, offset2 = 0) {
        return BufferLayout4.u32().span + BufferLayout4.u32().span + new import_bn2.default(new Uint8Array(b).slice(offset2, offset2 + 4), 10, "le").toNumber();
      }
    };
    LAYOUT2 = BufferLayout4.union(BufferLayout4.u32("instruction"));
    LAYOUT2.addVariant(0, BufferLayout4.struct([
      BufferLayout4.ns64("lamports"),
      BufferLayout4.ns64("space"),
      publicKey4("owner")
    ]), "createAccount");
    LAYOUT2.addVariant(1, BufferLayout4.struct([publicKey4("owner")]), "assign");
    LAYOUT2.addVariant(2, BufferLayout4.struct([BufferLayout4.ns64("lamports")]), "transfer");
    LAYOUT2.addVariant(3, BufferLayout4.struct([
      publicKey4("base"),
      rustStringLayout("seed"),
      BufferLayout4.ns64("lamports"),
      BufferLayout4.ns64("space"),
      publicKey4("owner")
    ]), "createAccountWithSeed");
    LAYOUT2.addVariant(4, BufferLayout4.struct([publicKey4("authorized")]), "advanceNonceAccount");
    LAYOUT2.addVariant(5, BufferLayout4.struct([BufferLayout4.ns64("lamports")]), "withdrawNonceAccount");
    LAYOUT2.addVariant(6, BufferLayout4.struct([publicKey4("authorized")]), "initializeNonceAccount");
    LAYOUT2.addVariant(7, BufferLayout4.struct([publicKey4("authorized")]), "authorizeNonceAccount");
    LAYOUT2.addVariant(8, BufferLayout4.struct([BufferLayout4.ns64("space")]), "allocate");
    LAYOUT2.addVariant(9, BufferLayout4.struct([
      publicKey4("base"),
      rustStringLayout("seed"),
      BufferLayout4.ns64("space"),
      publicKey4("owner")
    ]), "allocateWithSeed");
    LAYOUT2.addVariant(10, BufferLayout4.struct([
      publicKey4("base"),
      rustStringLayout("seed"),
      publicKey4("owner")
    ]), "assignWithSeed");
    LAYOUT2.addVariant(11, BufferLayout4.struct([
      BufferLayout4.ns64("lamports"),
      rustStringLayout("seed"),
      publicKey4("owner")
    ]), "transferWithSeed");
    instructionMaxSpan2 = Math.max(...Object.values(LAYOUT2.registry).map((r) => r.span));
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/system/state.js
var SystemStateCoder;
var init_state3 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/system/state.js"() {
    init_define_process_env();
    SystemStateCoder = class {
      constructor(_idl) {
      }
      encode(_name, _account) {
        throw new Error("System does not have state");
      }
      decode(_ix) {
        throw new Error("System does not have state");
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/system/accounts.js
function decodeNonceAccount(ix) {
  return NONCE_ACCOUNT_LAYOUT.decode(ix);
}
function publicKey5(property) {
  return new WrappedLayout2(BufferLayout5.blob(32), (b) => new PublicKey(b), (key) => key.toBuffer(), property);
}
var BufferLayout5, SystemAccountsCoder, WrappedLayout2, NONCE_ACCOUNT_LAYOUT;
var init_accounts3 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/system/accounts.js"() {
    init_define_process_env();
    BufferLayout5 = __toModule(require_Layout());
    init_index_browser_esm();
    init_common3();
    SystemAccountsCoder = class {
      constructor(idl) {
        this.idl = idl;
      }
      async encode(accountName, account) {
        switch (accountName) {
          case "nonce": {
            const buffer = Buffer.alloc(NONCE_ACCOUNT_LENGTH);
            const len = NONCE_ACCOUNT_LAYOUT.encode(account, buffer);
            return buffer.slice(0, len);
          }
          default: {
            throw new Error(`Invalid account name: ${accountName}`);
          }
        }
      }
      decode(accountName, ix) {
        return this.decodeUnchecked(accountName, ix);
      }
      decodeUnchecked(accountName, ix) {
        switch (accountName) {
          case "nonce": {
            return decodeNonceAccount(ix);
          }
          default: {
            throw new Error(`Invalid account name: ${accountName}`);
          }
        }
      }
      memcmp(accountName, _appendData) {
        switch (accountName) {
          case "nonce": {
            return {
              dataSize: NONCE_ACCOUNT_LENGTH
            };
          }
          default: {
            throw new Error(`Invalid account name: ${accountName}`);
          }
        }
      }
      size(idlAccount) {
        var _a2;
        return (_a2 = accountSize(this.idl, idlAccount)) !== null && _a2 !== void 0 ? _a2 : 0;
      }
    };
    WrappedLayout2 = class extends BufferLayout5.Layout {
      constructor(layout, decoder, encoder, property) {
        super(layout.span, property);
        this.layout = layout;
        this.decoder = decoder;
        this.encoder = encoder;
      }
      decode(b, offset2) {
        return this.decoder(this.layout.decode(b, offset2));
      }
      encode(src, b, offset2) {
        return this.layout.encode(this.encoder(src), b, offset2);
      }
      getSpan(b, offset2) {
        return this.layout.getSpan(b, offset2);
      }
    };
    NONCE_ACCOUNT_LAYOUT = BufferLayout5.struct([
      BufferLayout5.u32("version"),
      BufferLayout5.u32("state"),
      publicKey5("authorizedPubkey"),
      publicKey5("nonce"),
      BufferLayout5.struct([BufferLayout5.nu64("lamportsPerSignature")], "feeCalculator")
    ]);
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/system/events.js
var SystemEventsCoder;
var init_events2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/system/events.js"() {
    init_define_process_env();
    SystemEventsCoder = class {
      constructor(_idl) {
      }
      decode(_log) {
        throw new Error("System program does not have events");
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/system/types.js
var SystemTypesCoder;
var init_types3 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/system/types.js"() {
    init_define_process_env();
    SystemTypesCoder = class {
      constructor(_idl) {
      }
      encode(_name, _type) {
        throw new Error("System does not have user-defined types");
      }
      decode(_name, _typeData) {
        throw new Error("System does not have user-defined types");
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/system/index.js
var SystemCoder;
var init_system = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/system/index.js"() {
    init_define_process_env();
    init_instruction3();
    init_state3();
    init_accounts3();
    init_events2();
    init_types3();
    SystemCoder = class {
      constructor(idl) {
        this.instruction = new SystemInstructionCoder(idl);
        this.accounts = new SystemAccountsCoder(idl);
        this.events = new SystemEventsCoder(idl);
        this.state = new SystemStateCoder(idl);
        this.types = new SystemTypesCoder(idl);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/coder/index.js
var init_coder = __esm({
  "node_modules/@project-serum/anchor/dist/esm/coder/index.js"() {
    init_define_process_env();
    init_borsh();
    init_spl_token();
    init_system();
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/pubkey.js
var pubkey_exports = {};
__export(pubkey_exports, {
  associated: () => associated,
  createProgramAddressSync: () => createProgramAddressSync,
  createWithSeedSync: () => createWithSeedSync,
  findProgramAddressSync: () => findProgramAddressSync
});
function createWithSeedSync(fromPublicKey, seed2, programId) {
  const buffer = import_buffer9.Buffer.concat([
    fromPublicKey.toBuffer(),
    import_buffer9.Buffer.from(seed2),
    programId.toBuffer()
  ]);
  const hash2 = import_js_sha2566.sha256.digest(buffer);
  return new PublicKey(import_buffer9.Buffer.from(hash2));
}
function createProgramAddressSync(seeds, programId) {
  const MAX_SEED_LENGTH = 32;
  let buffer = import_buffer9.Buffer.alloc(0);
  seeds.forEach(function(seed2) {
    if (seed2.length > MAX_SEED_LENGTH) {
      throw new TypeError(`Max seed length exceeded`);
    }
    buffer = import_buffer9.Buffer.concat([buffer, toBuffer(seed2)]);
  });
  buffer = import_buffer9.Buffer.concat([
    buffer,
    programId.toBuffer(),
    import_buffer9.Buffer.from("ProgramDerivedAddress")
  ]);
  let hash2 = (0, import_js_sha2566.sha256)(new Uint8Array(buffer));
  let publicKeyBytes = new import_bn3.default(hash2, 16).toArray(void 0, 32);
  if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {
    throw new Error(`Invalid seeds, address must fall off the curve`);
  }
  return new PublicKey(publicKeyBytes);
}
function findProgramAddressSync(seeds, programId) {
  let nonce = 255;
  let address;
  while (nonce != 0) {
    try {
      const seedsWithNonce = seeds.concat(import_buffer9.Buffer.from([nonce]));
      address = createProgramAddressSync(seedsWithNonce, programId);
    } catch (err2) {
      if (err2 instanceof TypeError) {
        throw err2;
      }
      nonce--;
      continue;
    }
    return [address, nonce];
  }
  throw new Error(`Unable to find a viable program address nonce`);
}
async function associated(programId, ...args) {
  let seeds = [import_buffer9.Buffer.from([97, 110, 99, 104, 111, 114])];
  args.forEach((arg) => {
    seeds.push(arg instanceof import_buffer9.Buffer ? arg : translateAddress(arg).toBuffer());
  });
  const [assoc] = await PublicKey.findProgramAddress(seeds, translateAddress(programId));
  return assoc;
}
var import_buffer9, import_bn3, import_js_sha2566, toBuffer;
var init_pubkey = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/pubkey.js"() {
    init_define_process_env();
    import_buffer9 = __toModule(require_buffer());
    import_bn3 = __toModule(require_bn());
    import_js_sha2566 = __toModule(require_sha256());
    init_index_browser_esm();
    init_common2();
    toBuffer = (arr) => {
      if (arr instanceof import_buffer9.Buffer) {
        return arr;
      } else if (arr instanceof Uint8Array) {
        return import_buffer9.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
      } else {
        return import_buffer9.Buffer.from(arr);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/utils/token.js
var token_exports = {};
__export(token_exports, {
  ASSOCIATED_PROGRAM_ID: () => ASSOCIATED_PROGRAM_ID,
  TOKEN_PROGRAM_ID: () => TOKEN_PROGRAM_ID,
  associatedAddress: () => associatedAddress
});
async function associatedAddress({ mint, owner }) {
  return (await PublicKey.findProgramAddress([owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], ASSOCIATED_PROGRAM_ID))[0];
}
var TOKEN_PROGRAM_ID, ASSOCIATED_PROGRAM_ID;
var init_token = __esm({
  "node_modules/@project-serum/anchor/dist/esm/utils/token.js"() {
    init_define_process_env();
    init_index_browser_esm();
    TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    ASSOCIATED_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports2, module) {
    init_define_process_env();
    var global = typeof self !== "undefined" ? self : exports2;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global.DOMException;
      }
      F.prototype = global;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports3) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob5) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob5);
          return promise;
        }
        function readBlobAsText(blob5) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob5);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode5);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode5(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports3.DOMException = self2.DOMException;
        try {
          new exports3.DOMException();
        } catch (err2) {
          exports3.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports3.DOMException.prototype = Object.create(Error.prototype);
          exports3.DOMException.prototype.constructor = exports3.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports3.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports3.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports3.Headers = Headers;
        exports3.Request = Request;
        exports3.Response = Response;
        exports3.fetch = fetch2;
        Object.defineProperty(exports3, "__esModule", { value: true });
        return exports3;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports2 = ctx.fetch;
    exports2.default = ctx.fetch;
    exports2.fetch = ctx.fetch;
    exports2.Headers = ctx.Headers;
    exports2.Request = ctx.Request;
    exports2.Response = ctx.Response;
    module.exports = exports2;
  }
});

// node_modules/pako/dist/pako.esm.mjs
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Z_FIXED$1, Z_BINARY, Z_TEXT, Z_UNKNOWN$1, STORED_BLOCK, STATIC_TREES, DYN_TREES, MIN_MATCH$1, MAX_MATCH$1, LENGTH_CODES$1, LITERALS$1, L_CODES$1, D_CODES$1, BL_CODES$1, HEAP_SIZE$1, MAX_BITS$1, Buf_size, MAX_BL_BITS, END_BLOCK, REP_3_6, REPZ_3_10, REPZ_11_138, extra_lbits, extra_dbits, extra_blbits, bl_order, DIST_CODE_LEN, static_ltree, static_dtree, _dist_code, _length_code, base_length, base_dist, static_l_desc, static_d_desc, static_bl_desc, d_code, put_short, send_bits, send_code, bi_reverse, bi_flush, gen_bitlen, gen_codes, tr_static_init, init_block, bi_windup, copy_block, smaller, pqdownheap, compress_block, build_tree, scan_tree, send_tree, build_bl_tree, send_all_trees, detect_data_type, static_init_done, _tr_init$1, _tr_stored_block$1, _tr_align$1, _tr_flush_block$1, _tr_tally$1, _tr_init_1, _tr_stored_block_1, _tr_flush_block_1, _tr_tally_1, _tr_align_1, trees, adler32, adler32_1, makeTable, crcTable, crc32, crc32_1, messages, constants$2, _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align, Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH$1, Z_FINISH$3, Z_BLOCK$1, Z_OK$3, Z_STREAM_END$3, Z_STREAM_ERROR$2, Z_DATA_ERROR$2, Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED$2, MAX_MEM_LEVEL, MAX_WBITS$1, DEF_MEM_LEVEL, LENGTH_CODES, LITERALS, L_CODES, D_CODES, BL_CODES, HEAP_SIZE, MAX_BITS, MIN_MATCH, MAX_MATCH, MIN_LOOKAHEAD, PRESET_DICT, INIT_STATE, EXTRA_STATE, NAME_STATE, COMMENT_STATE, HCRC_STATE, BUSY_STATE, FINISH_STATE, BS_NEED_MORE, BS_BLOCK_DONE, BS_FINISH_STARTED, BS_FINISH_DONE, OS_CODE, err, rank, zero, HASH_ZLIB, HASH, flush_pending, flush_block_only, put_byte, putShortMSB, read_buf, longest_match, fill_window, deflate_stored, deflate_fast, deflate_slow, deflate_rle, deflate_huff, configuration_table, lm_init, deflateResetKeep, deflateReset, deflateSetHeader, deflateInit2, deflateInit, deflate$2, deflateEnd, deflateSetDictionary, deflateInit_1, deflateInit2_1, deflateReset_1, deflateResetKeep_1, deflateSetHeader_1, deflate_2$1, deflateEnd_1, deflateSetDictionary_1, deflateInfo, deflate_1$2, _has, assign, flattenChunks, common, STR_APPLY_UIA_OK, _utf8len, string2buf, buf2binstring, buf2string, utf8border, strings, zstream, toString$1, Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH$2, Z_OK$2, Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED$1, BAD$1, TYPE$1, inffast, MAXBITS, ENOUGH_LENS$1, ENOUGH_DISTS$1, CODES$1, LENS$1, DISTS$1, lbase, lext, dbase, dext, inflate_table, inftrees, CODES, LENS, DISTS, Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK$1, Z_STREAM_END$1, Z_NEED_DICT$1, Z_STREAM_ERROR$1, Z_DATA_ERROR$1, Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED, HEAD, FLAGS, TIME, OS, EXLEN, EXTRA, NAME, COMMENT, HCRC, DICTID, DICT, TYPE, TYPEDO, STORED, COPY_, COPY, TABLE, LENLENS, CODELENS, LEN_, LEN, LENEXT, DIST, DISTEXT, MATCH, LIT, CHECK, LENGTH, DONE, BAD, MEM, SYNC, ENOUGH_LENS, ENOUGH_DISTS, MAX_WBITS, DEF_WBITS, zswap32, inflateResetKeep, inflateReset, inflateReset2, inflateInit2, inflateInit, virgin, lenfix, distfix, fixedtables, updatewindow, inflate$2, inflateEnd, inflateGetHeader, inflateSetDictionary, inflateReset_1, inflateReset2_1, inflateResetKeep_1, inflateInit_1, inflateInit2_1, inflate_2$1, inflateEnd_1, inflateGetHeader_1, inflateSetDictionary_1, inflateInfo, inflate_1$2, gzheader, toString, Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Inflate_1$1, inflate_2, inflateRaw_1$1, ungzip$1, constants, inflate_1$1, Inflate, inflate, inflateRaw, ungzip, inflate_1;
var init_pako_esm = __esm({
  "node_modules/pako/dist/pako.esm.mjs"() {
    init_define_process_env();
    Z_FIXED$1 = 4;
    Z_BINARY = 0;
    Z_TEXT = 1;
    Z_UNKNOWN$1 = 2;
    STORED_BLOCK = 0;
    STATIC_TREES = 1;
    DYN_TREES = 2;
    MIN_MATCH$1 = 3;
    MAX_MATCH$1 = 258;
    LENGTH_CODES$1 = 29;
    LITERALS$1 = 256;
    L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    D_CODES$1 = 30;
    BL_CODES$1 = 19;
    HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    MAX_BITS$1 = 15;
    Buf_size = 16;
    MAX_BL_BITS = 7;
    END_BLOCK = 256;
    REP_3_6 = 16;
    REPZ_3_10 = 17;
    REPZ_11_138 = 18;
    extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    DIST_CODE_LEN = 512;
    static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    send_code = (s, c, tree) => {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    };
    bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS$1 + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS$1; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS$1 + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES$1; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
      for (n = 0; n < D_CODES$1; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
    };
    init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES$1; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES$1; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES$1; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    };
    bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    copy_block = (s, buf, len, header) => {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
      s.pending += len;
    };
    smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let lx = 0;
      let code;
      let extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS$1 + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    };
    build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE$1;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank2;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    detect_data_type = (s) => {
      let black_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS$1; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    static_init_done = false;
    _tr_init$1 = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    _tr_stored_block$1 = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    };
    _tr_align$1 = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    _tr_flush_block$1 = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN$1) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    _tr_tally$1 = (s, dist, lc) => {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    };
    _tr_init_1 = _tr_init$1;
    _tr_stored_block_1 = _tr_stored_block$1;
    _tr_flush_block_1 = _tr_flush_block$1;
    _tr_tally_1 = _tr_tally$1;
    _tr_align_1 = _tr_align$1;
    trees = {
      _tr_init: _tr_init_1,
      _tr_stored_block: _tr_stored_block_1,
      _tr_flush_block: _tr_flush_block_1,
      _tr_tally: _tr_tally_1,
      _tr_align: _tr_align_1
    };
    adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    adler32_1 = adler32;
    makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    crcTable = new Uint32Array(makeTable());
    crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    crc32_1 = crc32;
    messages = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
    };
    constants$2 = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
    };
    ({ _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees);
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$2,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH: Z_FULL_FLUSH$1,
      Z_FINISH: Z_FINISH$3,
      Z_BLOCK: Z_BLOCK$1,
      Z_OK: Z_OK$3,
      Z_STREAM_END: Z_STREAM_END$3,
      Z_STREAM_ERROR: Z_STREAM_ERROR$2,
      Z_DATA_ERROR: Z_DATA_ERROR$2,
      Z_BUF_ERROR: Z_BUF_ERROR$1,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
      Z_UNKNOWN,
      Z_DEFLATED: Z_DEFLATED$2
    } = constants$2);
    MAX_MEM_LEVEL = 9;
    MAX_WBITS$1 = 15;
    DEF_MEM_LEVEL = 8;
    LENGTH_CODES = 29;
    LITERALS = 256;
    L_CODES = LITERALS + 1 + LENGTH_CODES;
    D_CODES = 30;
    BL_CODES = 19;
    HEAP_SIZE = 2 * L_CODES + 1;
    MAX_BITS = 15;
    MIN_MATCH = 3;
    MAX_MATCH = 258;
    MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    PRESET_DICT = 32;
    INIT_STATE = 42;
    EXTRA_STATE = 69;
    NAME_STATE = 73;
    COMMENT_STATE = 91;
    HCRC_STATE = 103;
    BUSY_STATE = 113;
    FINISH_STATE = 666;
    BS_NEED_MORE = 1;
    BS_BLOCK_DONE = 2;
    BS_FINISH_STARTED = 3;
    BS_FINISH_DONE = 4;
    OS_CODE = 3;
    err = (strm, errorCode) => {
      strm.msg = messages[errorCode];
      return errorCode;
    };
    rank = (f) => {
      return (f << 1) - (f > 4 ? 9 : 0);
    };
    zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    HASH = HASH_ZLIB;
    flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    fill_window = (s) => {
      const _w_size = s.w_size;
      let p, n, m, more, str2;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str2 = s.strstart - s.insert;
          s.ins_h = s.window[str2];
          s.ins_h = HASH(s, s.ins_h, s.window[str2 + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
            s.prev[str2 & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str2;
            str2++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    deflate_stored = (s, flush) => {
      let max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        const max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    };
    deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow)
    ];
    lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    deflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH$2;
      _tr_init(s);
      return Z_OK$3;
    };
    deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK$3) {
        lm_init(strm.state);
      }
      return ret;
    };
    deflateSetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR$2;
      }
      strm.state.gzhead = head;
      return Z_OK$3;
    };
    deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR$2;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    };
    deflate$2 = (strm, flush) => {
      let beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
      }
      const s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
      }
      s.strm = strm;
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
        let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK$3;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK$1) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH$1) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        }
      }
      if (flush !== Z_FINISH$3) {
        return Z_OK$3;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END$3;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    deflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      const status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR$2;
      }
      if (wrap === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str2 = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
          s.prev[str2 & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str2;
          str2++;
        } while (--n);
        s.strstart = str2;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK$3;
    };
    deflateInit_1 = deflateInit;
    deflateInit2_1 = deflateInit2;
    deflateReset_1 = deflateReset;
    deflateResetKeep_1 = deflateResetKeep;
    deflateSetHeader_1 = deflateSetHeader;
    deflate_2$1 = deflate$2;
    deflateEnd_1 = deflateEnd;
    deflateSetDictionary_1 = deflateSetDictionary;
    deflateInfo = "pako deflate (from Nodeca project)";
    deflate_1$2 = {
      deflateInit: deflateInit_1,
      deflateInit2: deflateInit2_1,
      deflateReset: deflateReset_1,
      deflateResetKeep: deflateResetKeep_1,
      deflateSetHeader: deflateSetHeader_1,
      deflate: deflate_2$1,
      deflateEnd: deflateEnd_1,
      deflateSetDictionary: deflateSetDictionary_1,
      deflateInfo
    };
    _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    flattenChunks = (chunks2) => {
      let len = 0;
      for (let i = 0, l = chunks2.length; i < l; i++) {
        len += chunks2[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks2.length; i < l; i++) {
        let chunk = chunks2[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
    common = {
      assign,
      flattenChunks
    };
    STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    string2buf = (str2) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str2);
      }
      let buf, c, c2, m_pos, i, str_len = str2.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str2.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str2.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str2.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str2.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    strings = {
      string2buf,
      buf2string,
      utf8border
    };
    zstream = ZStream;
    toString$1 = Object.prototype.toString;
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$1,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH: Z_FINISH$2,
      Z_OK: Z_OK$2,
      Z_STREAM_END: Z_STREAM_END$2,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED: Z_DEFLATED$1
    } = constants$2);
    Deflate$1.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString$1.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1$2.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK$2) {
        this.result = common.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    BAD$1 = 30;
    TYPE$1 = 12;
    inffast = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD$1;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD$1;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE$1;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD$1;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
    MAXBITS = 15;
    ENOUGH_LENS$1 = 852;
    ENOUGH_DISTS$1 = 592;
    CODES$1 = 0;
    LENS$1 = 1;
    DISTS$1 = 2;
    lbase = new Uint16Array([
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    lext = new Uint8Array([
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    dbase = new Uint16Array([
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    dext = new Uint8Array([
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask2;
      let next;
      let base = null;
      let base_index = 0;
      let end;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let extra_index = 0;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type2 === CODES$1 || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type2 === CODES$1) {
        base = extra = work;
        end = 19;
      } else if (type2 === LENS$1) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask2 = used - 1;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask2) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
          }
          low = huff & mask2;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    inftrees = inflate_table;
    CODES = 0;
    LENS = 1;
    DISTS = 2;
    ({
      Z_FINISH: Z_FINISH$1,
      Z_BLOCK,
      Z_TREES,
      Z_OK: Z_OK$1,
      Z_STREAM_END: Z_STREAM_END$1,
      Z_NEED_DICT: Z_NEED_DICT$1,
      Z_STREAM_ERROR: Z_STREAM_ERROR$1,
      Z_DATA_ERROR: Z_DATA_ERROR$1,
      Z_MEM_ERROR: Z_MEM_ERROR$1,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = constants$2);
    HEAD = 1;
    FLAGS = 2;
    TIME = 3;
    OS = 4;
    EXLEN = 5;
    EXTRA = 6;
    NAME = 7;
    COMMENT = 8;
    HCRC = 9;
    DICTID = 10;
    DICT = 11;
    TYPE = 12;
    TYPEDO = 13;
    STORED = 14;
    COPY_ = 15;
    COPY = 16;
    TABLE = 17;
    LENLENS = 18;
    CODELENS = 19;
    LEN_ = 20;
    LEN = 21;
    LENEXT = 22;
    DIST = 23;
    DISTEXT = 24;
    MATCH = 25;
    LIT = 26;
    CHECK = 27;
    LENGTH = 28;
    DONE = 29;
    BAD = 30;
    MEM = 31;
    SYNC = 32;
    ENOUGH_LENS = 852;
    ENOUGH_DISTS = 592;
    MAX_WBITS = 15;
    DEF_WBITS = MAX_WBITS;
    zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    inflateResetKeep = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK$1;
    };
    inflateReset = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR$1;
      }
      const state = new InflateState();
      strm.state = state;
      state.window = null;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK$1) {
        strm.state = null;
      }
      return ret;
    };
    inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    virgin = true;
    fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    inflate$2 = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK$1;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32_1(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(input.subarray(next, next + copy), len);
                  }
                  if (state.flags & 512) {
                    state.check = crc32_1(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT$1;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inffast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END$1;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR$1;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR$1;
            case SYNC:
            default:
              return Z_STREAM_ERROR$1;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
          ;
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    inflateEnd = (strm) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK$1;
    };
    inflateGetHeader = (strm, head) => {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR$1;
      }
      state.head = head;
      head.done = false;
      return Z_OK$1;
    };
    inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR$1;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR$1;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
      }
      state.havedict = 1;
      return Z_OK$1;
    };
    inflateReset_1 = inflateReset;
    inflateReset2_1 = inflateReset2;
    inflateResetKeep_1 = inflateResetKeep;
    inflateInit_1 = inflateInit;
    inflateInit2_1 = inflateInit2;
    inflate_2$1 = inflate$2;
    inflateEnd_1 = inflateEnd;
    inflateGetHeader_1 = inflateGetHeader;
    inflateSetDictionary_1 = inflateSetDictionary;
    inflateInfo = "pako inflate (from Nodeca project)";
    inflate_1$2 = {
      inflateReset: inflateReset_1,
      inflateReset2: inflateReset2_1,
      inflateResetKeep: inflateResetKeep_1,
      inflateInit: inflateInit_1,
      inflateInit2: inflateInit2_1,
      inflate: inflate_2$1,
      inflateEnd: inflateEnd_1,
      inflateGetHeader: inflateGetHeader_1,
      inflateSetDictionary: inflateSetDictionary_1,
      inflateInfo
    };
    gzheader = GZheader;
    toString = Object.prototype.toString;
    ({
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = constants$2);
    Inflate$1.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = inflate_1$2.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = inflate_1$2.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          inflate_1$2.inflateReset(strm);
          status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = inflate_1$2.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = common.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Inflate_1$1 = Inflate$1;
    inflate_2 = inflate$1;
    inflateRaw_1$1 = inflateRaw$1;
    ungzip$1 = inflate$1;
    constants = constants$2;
    inflate_1$1 = {
      Inflate: Inflate_1$1,
      inflate: inflate_2,
      inflateRaw: inflateRaw_1$1,
      ungzip: ungzip$1,
      constants
    };
    ({ Inflate, inflate, inflateRaw, ungzip } = inflate_1$1);
    inflate_1 = inflate;
  }
});

// node_modules/@project-serum/anchor/dist/esm/idl.js
async function idlAddress(programId) {
  const base = (await PublicKey.findProgramAddress([], programId))[0];
  return await PublicKey.createWithSeed(base, seed(), programId);
}
function seed() {
  return "anchor:idl";
}
function decodeIdlAccount(data) {
  return IDL_ACCOUNT_LAYOUT.decode(data);
}
var import_buffer10, borsh4, IDL_ACCOUNT_LAYOUT;
var init_idl2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/idl.js"() {
    init_define_process_env();
    import_buffer10 = __toModule(require_buffer());
    init_index_browser_esm();
    borsh4 = __toModule(require_lib());
    IDL_ACCOUNT_LAYOUT = borsh4.struct([
      borsh4.publicKey("authority"),
      borsh4.vecU8("data")
    ]);
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/context.js
function splitArgsAndCtx(idlIx, args) {
  var _a2, _b;
  let options = {};
  const inputLen = idlIx.args ? idlIx.args.length : 0;
  if (args.length > inputLen) {
    if (args.length !== inputLen + 1) {
      throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a2 = idlIx.args) === null || _a2 === void 0 ? void 0 : _a2.map((a) => a.name)) !== null && _b !== void 0 ? _b : []}`);
    }
    options = args.pop();
  }
  return [args, options];
}
var init_context = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/context.js"() {
    init_define_process_env();
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/instruction.js
function validateInstruction(ix, ...args) {
}
var InstructionNamespaceFactory;
var init_instruction4 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/instruction.js"() {
    init_define_process_env();
    init_index_browser_esm();
    init_error();
    init_common2();
    init_context();
    init_features();
    InstructionNamespaceFactory = class {
      static build(idlIx, encodeFn, programId) {
        if (idlIx.name === "_inner") {
          throw new IdlError("the _inner name is reserved");
        }
        const ix = (...args) => {
          const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);
          validateAccounts(idlIx.accounts, ctx.accounts);
          validateInstruction(idlIx, ...args);
          const keys = ix.accounts(ctx.accounts);
          if (ctx.remainingAccounts !== void 0) {
            keys.push(...ctx.remainingAccounts);
          }
          if (isSet("debug-logs")) {
            console.log("Outgoing account metas:", keys);
          }
          return new TransactionInstruction({
            keys,
            programId,
            data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))
          });
        };
        ix["accounts"] = (accs) => {
          return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, idlIx.name);
        };
        return ix;
      }
      static accountsArray(ctx, accounts, ixName) {
        if (!ctx) {
          return [];
        }
        return accounts.map((acc) => {
          const nestedAccounts = "accounts" in acc ? acc.accounts : void 0;
          if (nestedAccounts !== void 0) {
            const rpcAccs = ctx[acc.name];
            return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, ixName).flat();
          } else {
            const account = acc;
            let pubkey;
            try {
              pubkey = translateAddress(ctx[acc.name]);
            } catch (err2) {
              throw new Error(`Wrong input type for account "${acc.name}" in the instruction accounts object${ixName !== void 0 ? ' for instruction "' + ixName + '"' : ""}. Expected PublicKey or string.`);
            }
            return {
              pubkey,
              isWritable: account.isMut,
              isSigner: account.isSigner
            };
          }
        }).flat();
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/rpc.js
var RpcFactory;
var init_rpc2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/rpc.js"() {
    init_define_process_env();
    init_context();
    init_error();
    RpcFactory = class {
      static build(idlIx, txFn, idlErrors, provider) {
        const rpc = async (...args) => {
          var _a2;
          const tx = txFn(...args);
          const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
          if (provider.sendAndConfirm === void 0) {
            throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
          }
          try {
            return await provider.sendAndConfirm(tx, (_a2 = ctx.signers) !== null && _a2 !== void 0 ? _a2 : [], ctx.options);
          } catch (err2) {
            throw translateError(err2, idlErrors);
          }
        };
        return rpc;
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/transaction.js
var TransactionFactory;
var init_transaction = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/transaction.js"() {
    init_define_process_env();
    init_index_browser_esm();
    init_context();
    TransactionFactory = class {
      static build(idlIx, ixFn) {
        const txFn = (...args) => {
          var _a2, _b, _c;
          const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
          const tx = new Transaction();
          if (ctx.preInstructions && ctx.instructions) {
            throw new Error("instructions is deprecated, use preInstructions");
          }
          (_a2 = ctx.preInstructions) === null || _a2 === void 0 ? void 0 : _a2.forEach((ix) => tx.add(ix));
          (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach((ix) => tx.add(ix));
          tx.add(ixFn(...args));
          (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach((ix) => tx.add(ix));
          return tx;
        };
        return txFn;
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/state.js
function programStateAddress(programId) {
  let [registrySigner] = findProgramAddressSync([], programId);
  return createWithSeedSync(registrySigner, "unversioned", programId);
}
function stateInstructionKeys(programId, provider, m, accounts) {
  if (m.name === "new") {
    const [programSigner] = findProgramAddressSync([], programId);
    if (provider.wallet === void 0) {
      throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
    }
    return [
      {
        pubkey: provider.wallet.publicKey,
        isWritable: false,
        isSigner: true
      },
      {
        pubkey: programStateAddress(programId),
        isWritable: true,
        isSigner: false
      },
      { pubkey: programSigner, isWritable: false, isSigner: false },
      {
        pubkey: SystemProgram.programId,
        isWritable: false,
        isSigner: false
      },
      { pubkey: programId, isWritable: false, isSigner: false }
    ];
  } else {
    validateAccounts(m.accounts, accounts);
    return [
      {
        pubkey: programStateAddress(programId),
        isWritable: true,
        isSigner: false
      }
    ];
  }
}
var import_eventemitter3, import_camelcase6, StateFactory, StateClient;
var init_state4 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/state.js"() {
    init_define_process_env();
    import_eventemitter3 = __toModule(require_eventemitter3());
    import_camelcase6 = __toModule(require_camelcase());
    init_index_browser_esm();
    init_provider();
    init_coder();
    init_common2();
    init_pubkey();
    init_instruction4();
    init_rpc2();
    init_transaction();
    StateFactory = class {
      static build(idl, coder4, programId, provider) {
        if (idl.state === void 0) {
          return void 0;
        }
        return new StateClient(idl, programId, provider, coder4);
      }
    };
    StateClient = class {
      constructor(idl, programId, provider = getProvider(), coder4 = new BorshCoder(idl)) {
        this.provider = provider;
        this.coder = coder4;
        this._idl = idl;
        this._programId = programId;
        this._address = programStateAddress(programId);
        this._sub = null;
        const [instruction, transaction, rpc] = (() => {
          var _a2;
          let instruction2 = {};
          let transaction2 = {};
          let rpc2 = {};
          (_a2 = idl.state) === null || _a2 === void 0 ? void 0 : _a2.methods.forEach((m) => {
            const ixItem = InstructionNamespaceFactory.build(m, (ixName, ix) => coder4.instruction.encodeState(ixName, ix), programId);
            ixItem["accounts"] = (accounts) => {
              const keys = stateInstructionKeys(programId, provider, m, accounts);
              return keys.concat(InstructionNamespaceFactory.accountsArray(accounts, m.accounts, m.name));
            };
            const txItem = TransactionFactory.build(m, ixItem);
            const rpcItem = RpcFactory.build(m, txItem, parseIdlErrors(idl), provider);
            const name = (0, import_camelcase6.default)(m.name);
            instruction2[name] = ixItem;
            transaction2[name] = txItem;
            rpc2[name] = rpcItem;
          });
          return [
            instruction2,
            transaction2,
            rpc2
          ];
        })();
        this.instruction = instruction;
        this.transaction = transaction;
        this.rpc = rpc;
      }
      get programId() {
        return this._programId;
      }
      async fetch() {
        const addr = this.address();
        const accountInfo = await this.provider.connection.getAccountInfo(addr);
        if (accountInfo === null) {
          throw new Error(`Account does not exist ${addr.toString()}`);
        }
        const state = this._idl.state;
        if (!state) {
          throw new Error("State is not specified in IDL.");
        }
        const expectedDiscriminator = await stateDiscriminator(state.struct.name);
        if (expectedDiscriminator.compare(accountInfo.data.slice(0, 8))) {
          throw new Error("Invalid account discriminator");
        }
        return this.coder.state.decode(accountInfo.data);
      }
      address() {
        return this._address;
      }
      subscribe(commitment) {
        if (this._sub !== null) {
          return this._sub.ee;
        }
        const ee = new import_eventemitter3.default();
        const listener = this.provider.connection.onAccountChange(this.address(), (acc) => {
          const account = this.coder.state.decode(acc.data);
          ee.emit("change", account);
        }, commitment);
        this._sub = {
          ee,
          listener
        };
        return ee;
      }
      unsubscribe() {
        if (this._sub !== null) {
          this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => {
            this._sub = null;
          }).catch(console.error);
        }
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/account.js
var import_camelcase7, import_eventemitter32, AccountFactory, AccountClient, subscriptions;
var init_account = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/account.js"() {
    init_define_process_env();
    import_camelcase7 = __toModule(require_camelcase());
    import_eventemitter32 = __toModule(require_eventemitter3());
    init_index_browser_esm();
    init_provider();
    init_coder();
    init_common2();
    init_pubkey();
    init_rpc();
    AccountFactory = class {
      static build(idl, coder4, programId, provider) {
        var _a2;
        const accountFns = {};
        (_a2 = idl.accounts) === null || _a2 === void 0 ? void 0 : _a2.forEach((idlAccount) => {
          const name = (0, import_camelcase7.default)(idlAccount.name);
          accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder4);
        });
        return accountFns;
      }
    };
    AccountClient = class {
      constructor(idl, idlAccount, programId, provider, coder4) {
        this._idlAccount = idlAccount;
        this._programId = programId;
        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();
        this._coder = coder4 !== null && coder4 !== void 0 ? coder4 : new BorshCoder(idl);
        this._size = this._coder.accounts.size(idlAccount);
      }
      get size() {
        return this._size;
      }
      get programId() {
        return this._programId;
      }
      get provider() {
        return this._provider;
      }
      get coder() {
        return this._coder;
      }
      async fetchNullable(address, commitment) {
        const accountInfo = await this.getAccountInfo(address, commitment);
        if (accountInfo === null) {
          return null;
        }
        return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);
      }
      async fetch(address, commitment) {
        const data = await this.fetchNullable(address, commitment);
        if (data === null) {
          throw new Error(`Account does not exist ${address.toString()}`);
        }
        return data;
      }
      async fetchMultiple(addresses, commitment) {
        const accounts = await getMultipleAccounts(this._provider.connection, addresses.map((address) => translateAddress(address)), commitment);
        return accounts.map((account) => {
          if (account == null) {
            return null;
          }
          return this._coder.accounts.decode(this._idlAccount.name, account === null || account === void 0 ? void 0 : account.account.data);
        });
      }
      async all(filters) {
        let resp = await this._provider.connection.getProgramAccounts(this._programId, {
          commitment: this._provider.connection.commitment,
          filters: [
            {
              memcmp: this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : void 0)
            },
            ...Array.isArray(filters) ? filters : []
          ]
        });
        return resp.map(({ pubkey, account }) => {
          return {
            publicKey: pubkey,
            account: this._coder.accounts.decode(this._idlAccount.name, account.data)
          };
        });
      }
      subscribe(address, commitment) {
        const sub = subscriptions.get(address.toString());
        if (sub) {
          return sub.ee;
        }
        const ee = new import_eventemitter32.default();
        address = translateAddress(address);
        const listener = this._provider.connection.onAccountChange(address, (acc) => {
          const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);
          ee.emit("change", account);
        }, commitment);
        subscriptions.set(address.toString(), {
          ee,
          listener
        });
        return ee;
      }
      async unsubscribe(address) {
        let sub = subscriptions.get(address.toString());
        if (!sub) {
          console.warn("Address is not subscribed");
          return;
        }
        if (subscriptions) {
          await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {
            subscriptions.delete(address.toString());
          }).catch(console.error);
        }
      }
      async createInstruction(signer, sizeOverride) {
        const size = this.size;
        if (this._provider.wallet === void 0) {
          throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
        }
        return SystemProgram.createAccount({
          fromPubkey: this._provider.wallet.publicKey,
          newAccountPubkey: signer.publicKey,
          space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,
          lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),
          programId: this._programId
        });
      }
      async associated(...args) {
        const addr = await this.associatedAddress(...args);
        return await this.fetch(addr);
      }
      async associatedAddress(...args) {
        return await associated(this._programId, ...args);
      }
      async getAccountInfo(address, commitment) {
        return await this._provider.connection.getAccountInfo(translateAddress(address), commitment);
      }
    };
    subscriptions = new Map();
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/event.js
var assert2, PROGRAM_LOG, PROGRAM_DATA, PROGRAM_LOG_START_INDEX, PROGRAM_DATA_START_INDEX, EventManager, EventParser, ExecutionContext, LogScanner;
var init_event2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/event.js"() {
    init_define_process_env();
    assert2 = __toModule(require_assert());
    PROGRAM_LOG = "Program log: ";
    PROGRAM_DATA = "Program data: ";
    PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;
    PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;
    EventManager = class {
      constructor(programId, provider, coder4) {
        this._programId = programId;
        this._provider = provider;
        this._eventParser = new EventParser(programId, coder4);
        this._eventCallbacks = new Map();
        this._eventListeners = new Map();
        this._listenerIdCount = 0;
      }
      addEventListener(eventName, callback) {
        var _a2;
        let listener = this._listenerIdCount;
        this._listenerIdCount += 1;
        if (!(eventName in this._eventCallbacks)) {
          this._eventListeners.set(eventName, []);
        }
        this._eventListeners.set(eventName, ((_a2 = this._eventListeners.get(eventName)) !== null && _a2 !== void 0 ? _a2 : []).concat(listener));
        this._eventCallbacks.set(listener, [eventName, callback]);
        if (this._onLogsSubscriptionId !== void 0) {
          return listener;
        }
        this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {
          if (logs.err) {
            return;
          }
          for (const event of this._eventParser.parseLogs(logs.logs)) {
            const allListeners = this._eventListeners.get(event.name);
            if (allListeners) {
              allListeners.forEach((listener2) => {
                const listenerCb = this._eventCallbacks.get(listener2);
                if (listenerCb) {
                  const [, callback2] = listenerCb;
                  callback2(event.data, ctx.slot, logs.signature);
                }
              });
            }
          }
        });
        return listener;
      }
      async removeEventListener(listener) {
        const callback = this._eventCallbacks.get(listener);
        if (!callback) {
          throw new Error(`Event listener ${listener} doesn't exist!`);
        }
        const [eventName] = callback;
        let listeners = this._eventListeners.get(eventName);
        if (!listeners) {
          throw new Error(`Event listeners don't exist for ${eventName}!`);
        }
        this._eventCallbacks.delete(listener);
        listeners = listeners.filter((l) => l !== listener);
        if (listeners.length === 0) {
          this._eventListeners.delete(eventName);
        }
        if (this._eventCallbacks.size == 0) {
          assert2.ok(this._eventListeners.size === 0);
          if (this._onLogsSubscriptionId !== void 0) {
            await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);
            this._onLogsSubscriptionId = void 0;
          }
        }
      }
    };
    EventParser = class {
      constructor(programId, coder4) {
        this.coder = coder4;
        this.programId = programId;
      }
      *parseLogs(logs) {
        const logScanner = new LogScanner(logs);
        const execution = new ExecutionContext();
        let log = logScanner.next();
        while (log !== null) {
          let [event, newProgram, didPop] = this.handleLog(execution, log);
          if (event) {
            yield event;
          }
          if (newProgram) {
            execution.push(newProgram);
          }
          if (didPop) {
            execution.pop();
          }
          log = logScanner.next();
        }
      }
      handleLog(execution, log) {
        if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {
          return this.handleProgramLog(log);
        } else {
          return [null, ...this.handleSystemLog(log)];
        }
      }
      handleProgramLog(log) {
        if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {
          const logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);
          const event = this.coder.events.decode(logStr);
          return [event, null, false];
        } else {
          return [null, ...this.handleSystemLog(log)];
        }
      }
      handleSystemLog(log) {
        const logStart = log.split(":")[0];
        if (logStart.match(/^Program (.*) success/g) !== null) {
          return [null, true];
        } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {
          return [this.programId.toString(), false];
        } else if (logStart.includes("invoke")) {
          return ["cpi", false];
        } else {
          return [null, false];
        }
      }
    };
    ExecutionContext = class {
      constructor() {
        this.stack = [];
      }
      program() {
        assert2.ok(this.stack.length > 0);
        return this.stack[this.stack.length - 1];
      }
      push(newProgram) {
        this.stack.push(newProgram);
      }
      pop() {
        assert2.ok(this.stack.length > 0);
        this.stack.pop();
      }
    };
    LogScanner = class {
      constructor(logs) {
        this.logs = logs;
      }
      next() {
        if (this.logs.length === 0) {
          return null;
        }
        let l = this.logs[0];
        this.logs = this.logs.slice(1);
        return l;
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/simulate.js
var SimulateFactory;
var init_simulate = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/simulate.js"() {
    init_define_process_env();
    init_context();
    init_event2();
    init_error();
    SimulateFactory = class {
      static build(idlIx, txFn, idlErrors, provider, coder4, programId, idl) {
        const simulate = async (...args) => {
          var _a2;
          const tx = txFn(...args);
          const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
          let resp = void 0;
          if (provider.simulate === void 0) {
            throw new Error("This function requires 'Provider.simulate' to be implemented.");
          }
          try {
            resp = await provider.simulate(tx, ctx.signers, (_a2 = ctx.options) === null || _a2 === void 0 ? void 0 : _a2.commitment);
          } catch (err2) {
            throw translateError(err2, idlErrors);
          }
          if (resp === void 0) {
            throw new Error("Unable to simulate transaction");
          }
          const logs = resp.logs;
          if (!logs) {
            throw new Error("Simulated logs not found");
          }
          const events = [];
          if (idl.events) {
            let parser = new EventParser(programId, coder4);
            for (const event of parser.parseLogs(logs)) {
              events.push(event);
            }
          }
          return { events, raw: logs };
        };
        return simulate;
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/spl/token.js
function program(provider) {
  return new Program(IDL, TOKEN_PROGRAM_ID2, provider, coder());
}
function coder() {
  return new SplTokenCoder(IDL);
}
var TOKEN_PROGRAM_ID2, IDL;
var init_token2 = __esm({
  "node_modules/@project-serum/anchor/dist/esm/spl/token.js"() {
    init_define_process_env();
    init_index_browser_esm();
    init_program();
    init_spl_token();
    TOKEN_PROGRAM_ID2 = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    IDL = {
      version: "0.1.0",
      name: "spl_token",
      instructions: [
        {
          name: "initializeMint",
          accounts: [
            {
              name: "mint",
              isMut: true,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "decimals",
              type: "u8"
            },
            {
              name: "mintAuthority",
              type: "publicKey"
            },
            {
              name: "freezeAuthority",
              type: {
                coption: "publicKey"
              }
            }
          ]
        },
        {
          name: "initializeAccount",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: false,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "initializeMultisig",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "m",
              type: "u8"
            }
          ]
        },
        {
          name: "transfer",
          accounts: [
            {
              name: "source",
              isMut: true,
              isSigner: false
            },
            {
              name: "destination",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            }
          ]
        },
        {
          name: "approve",
          accounts: [
            {
              name: "source",
              isMut: true,
              isSigner: false
            },
            {
              name: "delegate",
              isMut: false,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            }
          ]
        },
        {
          name: "revoke",
          accounts: [
            {
              name: "source",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: []
        },
        {
          name: "setAuthority",
          accounts: [
            {
              name: "mint",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "authorityType",
              type: "u8"
            },
            {
              name: "newAuthority",
              type: {
                coption: "publicKey"
              }
            }
          ]
        },
        {
          name: "mintTo",
          accounts: [
            {
              name: "mint",
              isMut: true,
              isSigner: false
            },
            {
              name: "to",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            }
          ]
        },
        {
          name: "burn",
          accounts: [
            {
              name: "source",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            }
          ]
        },
        {
          name: "closeAccount",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            },
            {
              name: "destination",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "freezeAccount",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: false,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: []
        },
        {
          name: "thawAccount",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: false,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: []
        },
        {
          name: "transferChecked",
          accounts: [
            {
              name: "source",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: false,
              isSigner: false
            },
            {
              name: "destination",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            },
            {
              name: "decimals",
              type: "u8"
            }
          ]
        },
        {
          name: "approveChecked",
          accounts: [
            {
              name: "source",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: false,
              isSigner: false
            },
            {
              name: "delegate",
              isMut: false,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            },
            {
              name: "decimals",
              type: "u8"
            }
          ]
        },
        {
          name: "mintToChecked",
          accounts: [
            {
              name: "mint",
              isMut: true,
              isSigner: false
            },
            {
              name: "to",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            },
            {
              name: "decimals",
              type: "u8"
            }
          ]
        },
        {
          name: "burnChecked",
          accounts: [
            {
              name: "source",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: true,
              isSigner: false
            },
            {
              name: "authority",
              isMut: false,
              isSigner: true
            }
          ],
          args: [
            {
              name: "amount",
              type: "u64"
            },
            {
              name: "decimals",
              type: "u8"
            }
          ]
        },
        {
          name: "initializeAccount2",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: false,
              isSigner: false
            },
            {
              name: "rent",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "authority",
              type: "publicKey"
            }
          ]
        },
        {
          name: "syncNative",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            }
          ],
          args: []
        },
        {
          name: "initializeAccount3",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            },
            {
              name: "mint",
              isMut: false,
              isSigner: false
            }
          ],
          args: [
            {
              name: "authority",
              type: "publicKey"
            }
          ]
        },
        {
          name: "initializeMultisig2",
          accounts: [
            {
              name: "account",
              isMut: true,
              isSigner: false
            }
          ],
          args: [
            {
              name: "m",
              type: "u8"
            }
          ]
        },
        {
          name: "initializeMint2",
          accounts: [
            {
              name: "mint",
              isMut: true,
              isSigner: false
            }
          ],
          args: [
            {
              name: "decimals",
              type: "u8"
            },
            {
              name: "mintAuthority",
              type: "publicKey"
            },
            {
              name: "freezeAuthority",
              type: {
                coption: "publicKey"
              }
            }
          ]
        }
      ],
      accounts: [
        {
          name: "mint",
          type: {
            kind: "struct",
            fields: [
              {
                name: "mintAuthority",
                type: {
                  coption: "publicKey"
                }
              },
              {
                name: "supply",
                type: "u64"
              },
              {
                name: "decimals",
                type: "u8"
              },
              {
                name: "isInitialized",
                type: "bool"
              },
              {
                name: "freezeAuthority",
                type: {
                  coption: "publicKey"
                }
              }
            ]
          }
        },
        {
          name: "token",
          type: {
            kind: "struct",
            fields: [
              {
                name: "mint",
                type: "publicKey"
              },
              {
                name: "authority",
                type: "publicKey"
              },
              {
                name: "amount",
                type: "u64"
              },
              {
                name: "delegate",
                type: {
                  coption: "publicKey"
                }
              },
              {
                name: "state",
                type: "u8"
              },
              {
                name: "isNative",
                type: {
                  coption: "u64"
                }
              },
              {
                name: "delegatedAmount",
                type: "u64"
              },
              {
                name: "closeAuthority",
                type: {
                  coption: "publicKey"
                }
              }
            ]
          }
        }
      ]
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/accounts-resolver.js
var import_camelcase8, AccountsResolver, AccountStore;
var init_accounts_resolver = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/accounts-resolver.js"() {
    init_define_process_env();
    import_camelcase8 = __toModule(require_camelcase());
    init_index_browser_esm();
    init_utf8();
    init_token();
    init_token2();
    AccountsResolver = class {
      constructor(_args, _accounts, _provider2, _programId, _idlIx, _accountNamespace) {
        this._args = _args;
        this._accounts = _accounts;
        this._provider = _provider2;
        this._programId = _programId;
        this._idlIx = _idlIx;
        this._accountStore = new AccountStore(_provider2, _accountNamespace);
      }
      async resolve() {
        for (let k = 0; k < this._idlIx.accounts.length; k += 1) {
          const accountDesc = this._idlIx.accounts[k];
          const accountDescName = (0, import_camelcase8.default)(accountDesc.name);
          if (accountDesc.isSigner && !this._accounts[accountDescName]) {
            if (this._provider.wallet === void 0) {
              throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
            }
            this._accounts[accountDescName] = this._provider.wallet.publicKey;
            continue;
          }
          if (Reflect.has(AccountsResolver.CONST_ACCOUNTS, accountDescName) && !this._accounts[accountDescName]) {
            this._accounts[accountDescName] = AccountsResolver.CONST_ACCOUNTS[accountDescName];
          }
        }
        for (let k = 0; k < this._idlIx.accounts.length; k += 1) {
          const accountDesc = this._idlIx.accounts[k];
          const accountDescName = (0, import_camelcase8.default)(accountDesc.name);
          if (accountDesc.pda && accountDesc.pda.seeds.length > 0 && !this._accounts[accountDescName]) {
            await this.autoPopulatePda(accountDesc);
            continue;
          }
        }
      }
      async autoPopulatePda(accountDesc) {
        if (!accountDesc.pda || !accountDesc.pda.seeds)
          throw new Error("Must have seeds");
        const seeds = await Promise.all(accountDesc.pda.seeds.map((seedDesc) => this.toBuffer(seedDesc)));
        const programId = await this.parseProgramId(accountDesc);
        const [pubkey] = await PublicKey.findProgramAddress(seeds, programId);
        this._accounts[(0, import_camelcase8.default)(accountDesc.name)] = pubkey;
      }
      async parseProgramId(accountDesc) {
        var _a2;
        if (!((_a2 = accountDesc.pda) === null || _a2 === void 0 ? void 0 : _a2.programId)) {
          return this._programId;
        }
        switch (accountDesc.pda.programId.kind) {
          case "const":
            return new PublicKey(this.toBufferConst(accountDesc.pda.programId.value));
          case "arg":
            return this.argValue(accountDesc.pda.programId);
          case "account":
            return await this.accountValue(accountDesc.pda.programId);
          default:
            throw new Error(`Unexpected program seed kind: ${accountDesc.pda.programId.kind}`);
        }
      }
      async toBuffer(seedDesc) {
        switch (seedDesc.kind) {
          case "const":
            return this.toBufferConst(seedDesc);
          case "arg":
            return await this.toBufferArg(seedDesc);
          case "account":
            return await this.toBufferAccount(seedDesc);
          default:
            throw new Error(`Unexpected seed kind: ${seedDesc.kind}`);
        }
      }
      toBufferConst(seedDesc) {
        return this.toBufferValue(seedDesc.type, seedDesc.value);
      }
      async toBufferArg(seedDesc) {
        const argValue = this.argValue(seedDesc);
        return this.toBufferValue(seedDesc.type, argValue);
      }
      argValue(seedDesc) {
        const seedArgName = (0, import_camelcase8.default)(seedDesc.path.split(".")[0]);
        const idlArgPosition = this._idlIx.args.findIndex((argDesc) => argDesc.name === seedArgName);
        if (idlArgPosition === -1) {
          throw new Error(`Unable to find argument for seed: ${seedArgName}`);
        }
        return this._args[idlArgPosition];
      }
      async toBufferAccount(seedDesc) {
        const accountValue = await this.accountValue(seedDesc);
        return this.toBufferValue(seedDesc.type, accountValue);
      }
      async accountValue(seedDesc) {
        const pathComponents = seedDesc.path.split(".");
        const fieldName = pathComponents[0];
        const fieldPubkey = this._accounts[(0, import_camelcase8.default)(fieldName)];
        if (pathComponents.length === 1) {
          return fieldPubkey;
        }
        const account = await this._accountStore.fetchAccount(seedDesc.account, fieldPubkey);
        const fieldValue = this.parseAccountValue(account, pathComponents.slice(1));
        return fieldValue;
      }
      parseAccountValue(account, path) {
        let accountField;
        while (path.length > 0) {
          accountField = account[(0, import_camelcase8.default)(path[0])];
          path = path.slice(1);
        }
        return accountField;
      }
      toBufferValue(type2, value) {
        switch (type2) {
          case "u8":
            return Buffer.from([value]);
          case "u16":
            let b = Buffer.alloc(2);
            b.writeUInt16LE(value);
            return b;
          case "u32":
            let buf = Buffer.alloc(4);
            buf.writeUInt32LE(value);
            return buf;
          case "u64":
            let bU64 = Buffer.alloc(8);
            bU64.writeBigUInt64LE(BigInt(value));
            return bU64;
          case "string":
            return Buffer.from(encode2(value));
          case "publicKey":
            return value.toBuffer();
          default:
            if (type2.array) {
              return Buffer.from(value);
            }
            throw new Error(`Unexpected seed type: ${type2}`);
        }
      }
    };
    AccountsResolver.CONST_ACCOUNTS = {
      associatedTokenProgram: ASSOCIATED_PROGRAM_ID,
      rent: SYSVAR_RENT_PUBKEY,
      systemProgram: SystemProgram.programId,
      tokenProgram: TOKEN_PROGRAM_ID
    };
    AccountStore = class {
      constructor(_provider2, _accounts) {
        this._provider = _provider2;
        this._accounts = _accounts;
        this._cache = new Map();
      }
      async fetchAccount(name, publicKey8) {
        const address = publicKey8.toString();
        if (!this._cache.has(address)) {
          if (name === "TokenAccount") {
            const accountInfo = await this._provider.connection.getAccountInfo(publicKey8);
            if (accountInfo === null) {
              throw new Error(`invalid account info for ${address}`);
            }
            const data = coder().accounts.decode("token", accountInfo.data);
            this._cache.set(address, data);
          } else {
            const account = this._accounts[(0, import_camelcase8.default)(name)].fetch(publicKey8);
            this._cache.set(address, account);
          }
        }
        return this._cache.get(address);
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/methods.js
var MethodsBuilderFactory, MethodsBuilder;
var init_methods = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/methods.js"() {
    init_define_process_env();
    init_accounts_resolver();
    MethodsBuilderFactory = class {
      static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace) {
        return (...args) => new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace);
      }
    };
    MethodsBuilder = class {
      constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, _provider2, _programId, _idlIx, _accountNamespace) {
        this._args = _args;
        this._ixFn = _ixFn;
        this._txFn = _txFn;
        this._rpcFn = _rpcFn;
        this._simulateFn = _simulateFn;
        this._viewFn = _viewFn;
        this._accounts = {};
        this._remainingAccounts = [];
        this._signers = [];
        this._preInstructions = [];
        this._postInstructions = [];
        this._autoResolveAccounts = true;
        this._accountsResolver = new AccountsResolver(_args, this._accounts, _provider2, _programId, _idlIx, _accountNamespace);
      }
      async pubkeys() {
        if (this._autoResolveAccounts) {
          await this._accountsResolver.resolve();
        }
        return this._accounts;
      }
      accounts(accounts) {
        this._autoResolveAccounts = true;
        Object.assign(this._accounts, accounts);
        return this;
      }
      accountsStrict(accounts) {
        this._autoResolveAccounts = false;
        Object.assign(this._accounts, accounts);
        return this;
      }
      signers(signers) {
        this._signers = this._signers.concat(signers);
        return this;
      }
      remainingAccounts(accounts) {
        this._remainingAccounts = this._remainingAccounts.concat(accounts);
        return this;
      }
      preInstructions(ixs) {
        this._preInstructions = this._preInstructions.concat(ixs);
        return this;
      }
      postInstructions(ixs) {
        this._postInstructions = this._postInstructions.concat(ixs);
        return this;
      }
      async rpc(options) {
        if (this._autoResolveAccounts) {
          await this._accountsResolver.resolve();
        }
        return this._rpcFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options
        });
      }
      async view(options) {
        if (this._autoResolveAccounts) {
          await this._accountsResolver.resolve();
        }
        if (!this._viewFn) {
          throw new Error("Method does not support views");
        }
        return this._viewFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options
        });
      }
      async simulate(options) {
        if (this._autoResolveAccounts) {
          await this._accountsResolver.resolve();
        }
        return this._simulateFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions,
          options
        });
      }
      async instruction() {
        if (this._autoResolveAccounts) {
          await this._accountsResolver.resolve();
        }
        return this._ixFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions
        });
      }
      async transaction() {
        if (this._autoResolveAccounts) {
          await this._accountsResolver.resolve();
        }
        return this._txFn(...this._args, {
          accounts: this._accounts,
          signers: this._signers,
          remainingAccounts: this._remainingAccounts,
          preInstructions: this._preInstructions,
          postInstructions: this._postInstructions
        });
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/views.js
var ViewFactory;
var init_views = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/views.js"() {
    init_define_process_env();
    init_idl();
    init_base64();
    ViewFactory = class {
      static build(programId, idlIx, simulateFn, idl) {
        const isMut = idlIx.accounts.find((a) => a.isMut);
        const hasReturn = !!idlIx.returns;
        if (isMut || !hasReturn)
          return;
        const view = async (...args) => {
          var _a2, _b;
          let simulationResult = await simulateFn(...args);
          const returnPrefix = `Program return: ${programId} `;
          let returnLog = simulationResult.raw.find((l) => l.startsWith(returnPrefix));
          if (!returnLog) {
            throw new Error("View expected return log");
          }
          let returnData = decode4(returnLog.slice(returnPrefix.length));
          let returnType = idlIx.returns;
          if (!returnType) {
            throw new Error("View expected return type");
          }
          const coder4 = IdlCoder.fieldLayout({ type: returnType }, Array.from([...(_a2 = idl.accounts) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
          return coder4.decode(returnData);
        };
        return view;
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/namespace/index.js
var import_camelcase9, NamespaceFactory;
var init_namespace = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/namespace/index.js"() {
    init_define_process_env();
    import_camelcase9 = __toModule(require_camelcase());
    init_state4();
    init_instruction4();
    init_transaction();
    init_rpc2();
    init_account();
    init_simulate();
    init_common2();
    init_methods();
    init_views();
    init_state4();
    init_account();
    init_methods();
    NamespaceFactory = class {
      static build(idl, coder4, programId, provider) {
        const rpc = {};
        const instruction = {};
        const transaction = {};
        const simulate = {};
        const methods = {};
        const view = {};
        const idlErrors = parseIdlErrors(idl);
        const account = idl.accounts ? AccountFactory.build(idl, coder4, programId, provider) : {};
        const state = StateFactory.build(idl, coder4, programId, provider);
        idl.instructions.forEach((idlIx) => {
          const ixItem = InstructionNamespaceFactory.build(idlIx, (ixName, ix) => coder4.instruction.encode(ixName, ix), programId);
          const txItem = TransactionFactory.build(idlIx, ixItem);
          const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);
          const simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder4, programId, idl);
          const viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);
          const methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account);
          const name = (0, import_camelcase9.default)(idlIx.name);
          instruction[name] = ixItem;
          transaction[name] = txItem;
          rpc[name] = rpcItem;
          simulate[name] = simulateItem;
          methods[name] = methodItem;
          if (viewItem) {
            view[name] = viewItem;
          }
        });
        return [
          rpc,
          instruction,
          transaction,
          account,
          simulate,
          methods,
          state,
          view
        ];
      }
    };
  }
});

// node_modules/@project-serum/anchor/dist/esm/program/index.js
var Program;
var init_program = __esm({
  "node_modules/@project-serum/anchor/dist/esm/program/index.js"() {
    init_define_process_env();
    init_pako_esm();
    init_provider();
    init_idl2();
    init_coder();
    init_namespace();
    init_bytes();
    init_event2();
    init_common2();
    init_common2();
    init_context();
    init_event2();
    init_namespace();
    Program = class {
      constructor(idl, programId, provider, coder4) {
        programId = translateAddress(programId);
        if (!provider) {
          provider = getProvider();
        }
        this._idl = idl;
        this._provider = provider;
        this._programId = programId;
        this._coder = coder4 !== null && coder4 !== void 0 ? coder4 : new BorshCoder(idl);
        this._events = new EventManager(this._programId, provider, this._coder);
        const [rpc, instruction, transaction, account, simulate, methods, state, views] = NamespaceFactory.build(idl, this._coder, programId, provider);
        this.rpc = rpc;
        this.instruction = instruction;
        this.transaction = transaction;
        this.account = account;
        this.simulate = simulate;
        this.methods = methods;
        this.state = state;
        this.views = views;
      }
      get programId() {
        return this._programId;
      }
      get idl() {
        return this._idl;
      }
      get coder() {
        return this._coder;
      }
      get provider() {
        return this._provider;
      }
      static async at(address, provider) {
        const programId = translateAddress(address);
        const idl = await Program.fetchIdl(programId, provider);
        if (!idl) {
          throw new Error(`IDL not found for program: ${address.toString()}`);
        }
        return new Program(idl, programId, provider);
      }
      static async fetchIdl(address, provider) {
        provider = provider !== null && provider !== void 0 ? provider : getProvider();
        const programId = translateAddress(address);
        const idlAddr = await idlAddress(programId);
        const accountInfo = await provider.connection.getAccountInfo(idlAddr);
        if (!accountInfo) {
          return null;
        }
        let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
        const inflatedIdl = inflate_1(idlAccount.data);
        return JSON.parse(utf8_exports.decode(inflatedIdl));
      }
      addEventListener(eventName, callback) {
        return this._events.addEventListener(eventName, callback);
      }
      async removeEventListener(listener) {
        return await this._events.removeEventListener(listener);
      }
    };
  }
});

// node_modules/toml/lib/parser.js
var require_parser = __commonJS({
  "node_modules/toml/lib/parser.js"(exports2, module) {
    init_define_process_env();
    module.exports = function() {
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function SyntaxError(message, expected, found, offset2, line, column) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset2;
        this.line = line;
        this.column = column;
        this.name = "SyntaxError";
      }
      peg$subclass(SyntaxError, Error);
      function parse2(input) {
        var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
          return nodes;
        }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
          addNode(node("ObjectPath", name, line, column));
        }, peg$c12 = function(name) {
          addNode(node("ArrayPath", name, line, column));
        }, peg$c13 = function(parts, name) {
          return parts.concat(name);
        }, peg$c14 = function(name) {
          return [name];
        }, peg$c15 = function(name) {
          return name;
        }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
          addNode(node("Assign", value, line, column, key));
        }, peg$c21 = function(chars) {
          return chars.join("");
        }, peg$c22 = function(node2) {
          return node2.value;
        }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
          return node("String", chars.join(""), line, column);
        }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
          return char;
        }, peg$c34 = function(char) {
          return char;
        }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
          return "";
        }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left, right) {
          return node("Float", parseFloat(left + "e" + right), line, column);
        }, peg$c43 = function(text2) {
          return node("Float", parseFloat(text2), line, column);
        }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
          return digits.join("");
        }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
          return "-" + digits.join("");
        }, peg$c50 = function(text2) {
          return node("Integer", parseInt(text2, 10), line, column);
        }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
          return node("Boolean", true, line, column);
        }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
          return node("Boolean", false, line, column);
        }, peg$c57 = function() {
          return node("Array", [], line, column);
        }, peg$c58 = function(value) {
          return node("Array", value ? [value] : [], line, column);
        }, peg$c59 = function(values) {
          return node("Array", values, line, column);
        }, peg$c60 = function(values, value) {
          return node("Array", values.concat(value), line, column);
        }, peg$c61 = function(value) {
          return value;
        }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values) {
          return node("InlineTable", values, line, column);
        }, peg$c69 = function(key, value) {
          return node("InlineTableValue", value, line, column, key);
        }, peg$c70 = function(digits) {
          return "." + digits;
        }, peg$c71 = function(date) {
          return date.join("");
        }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time) {
          return time.join("");
        }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date, time) {
          return node("Date", new Date(date + "T" + time + "Z"), line, column);
        }, peg$c80 = function(date, time) {
          return node("Date", new Date(date + "T" + time), line, column);
        }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
          return "";
        }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
          return d.join("");
        }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
          return '"';
        }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
          return "\\";
        }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
          return "\b";
        }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
          return "	";
        }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
          return "\n";
        }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
          return "\f";
        }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
          return "\r";
        }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
          return convertCodePoint(digits.join(""));
        }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$reportedPos, peg$currPos);
        }
        function offset2() {
          return peg$reportedPos;
        }
        function line() {
          return peg$computePosDetails(peg$reportedPos).line;
        }
        function column() {
          return peg$computePosDetails(peg$reportedPos).column;
        }
        function expected(description) {
          throw peg$buildException(null, [{ type: "other", description }], peg$reportedPos);
        }
        function error(message) {
          throw peg$buildException(message, null, peg$reportedPos);
        }
        function peg$computePosDetails(pos) {
          function advance(details, startPos, endPos) {
            var p, ch;
            for (p = startPos; p < endPos; p++) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
            }
          }
          if (peg$cachedPos !== pos) {
            if (peg$cachedPos > pos) {
              peg$cachedPos = 0;
              peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
            }
            advance(peg$cachedPosDetails, peg$cachedPos, pos);
            peg$cachedPos = pos;
          }
          return peg$cachedPosDetails;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildException(message, expected2, pos) {
          function cleanupExpected(expected3) {
            var i = 1;
            expected3.sort(function(a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i < expected3.length) {
              if (expected3[i - 1] === expected3[i]) {
                expected3.splice(i, 1);
              } else {
                i++;
              }
            }
          }
          function buildMessage(expected3, found2) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return "\\x" + hex(ch);
              }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                return "\\u0" + hex(ch);
              }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                return "\\u" + hex(ch);
              });
            }
            var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
            for (i = 0; i < expected3.length; i++) {
              expectedDescs[i] = expected3[i].description;
            }
            expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
            foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
          if (expected2 !== null) {
            cleanupExpected(expected2);
          }
          return new SyntaxError(message !== null ? message : buildMessage(expected2, found), expected2, found, pos, posDetails.line, posDetails.column);
        }
        function peg$parsestart() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 0, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseline();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseline();
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c1();
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseline() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 1, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseexpression();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsecomment();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parsecomment();
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseNL();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseNL();
                    }
                  } else {
                    s5 = peg$c2;
                  }
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseEOF();
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = [s1, s2, s3, s4, s5];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseNL();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseNL();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseEOF();
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parseNL();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseexpression() {
          var s0;
          var key = peg$currPos * 49 + 2, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsecomment();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepath();
            if (s0 === peg$FAILED) {
              s0 = peg$parsetablearray();
              if (s0 === peg$FAILED) {
                s0 = peg$parseassignment();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsecomment() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 3, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c3;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseNL();
            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c5;
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseNL();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = peg$c5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsepath() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 4, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetable_key();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c9;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c11(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetablearray() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key = peg$currPos * 49 + 5, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 91) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parsetable_key();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s6 = peg$c9;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s7 = peg$c9;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c12(s4);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 6, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsedot_ended_table_key_part();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsedot_ended_table_key_part();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsetable_key_part();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c13(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsetable_key_part();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c14(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key_part() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 7, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsequoted_key();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedot_ended_table_key_part() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 8, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsequoted_key();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseassignment() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 9, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsekey();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsevalue();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsequoted_key();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c18;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsevalue();
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c20(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsekey() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 10, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseASCII_BASIC();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseASCII_BASIC();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c21(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsequoted_key() {
          var s0, s1;
          var key = peg$currPos * 49 + 11, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedouble_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsesingle_quoted_single_line_string();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c22(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsevalue() {
          var s0;
          var key = peg$currPos * 49 + 12, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsestring();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedatetime();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefloat();
              if (s0 === peg$FAILED) {
                s0 = peg$parseinteger();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseboolean();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsearray();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseinline_table();
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring() {
          var s0;
          var key = peg$currPos * 49 + 13, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsedouble_quoted_multiline_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_quoted_single_line_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_multiline_string();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesingle_quoted_single_line_string();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_multiline_string() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 14, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsemultiline_string_char();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsemultiline_string_char();
              }
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c23) {
                  s4 = peg$c23;
                  peg$currPos += 3;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_single_line_string() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 15, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsestring_char();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestring_char();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c27;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_multiline_string() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 16, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s1 = peg$c29;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsemultiline_literal_char();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsemultiline_literal_char();
              }
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c29) {
                  s4 = peg$c29;
                  peg$currPos += 3;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_single_line_string() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 17, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c31;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseliteral_char();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseliteral_char();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s3 = peg$c31;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 18, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c27;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseliteral_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 19, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 20, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$parsemultiline_string_delim();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s2 = peg$c23;
                peg$currPos += 3;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = peg$c5;
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c34(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_delim() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 21, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c35;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c36);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseNLS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseNLS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c37();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_literal_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 22, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s2 = peg$c29;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 23, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 === peg$FAILED) {
            s1 = peg$parseinteger_text();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 101) {
              s2 = peg$c38;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c39);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 69) {
                s2 = peg$c40;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c41);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseinteger_text();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c42(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsefloat_text();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c43(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat_text() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 24, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDIGITS();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGITS();
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseDIGITS();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGITS();
                  if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger() {
          var s0, s1;
          var key = peg$currPos * 49 + 25, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseinteger_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger_text() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 26, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = peg$c5;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseDIGIT_OR_UNDER();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                  s3 = peg$c5;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c49(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseboolean() {
          var s0, s1;
          var key = peg$currPos * 49 + 27, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c51) {
            s1 = peg$c51;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c53();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c54) {
              s1 = peg$c54;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c55);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c56();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 28, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsearray_sep();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsearray_sep();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c57();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsearray_value();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c58(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsearray_value_list();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsearray_value_list();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c9;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c59(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                  s1 = peg$c7;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c8);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parsearray_value_list();
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$parsearray_value_list();
                    }
                  } else {
                    s2 = peg$c2;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsearray_value();
                    if (s3 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s4 = peg$c9;
                        peg$currPos++;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c60(s2, s3);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 29, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsearray_sep();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsevalue();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsearray_sep();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsearray_sep();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c61(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value_list() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 30, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsearray_sep();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsevalue();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsearray_sep();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsearray_sep();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c62;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c63);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parsearray_sep();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parsearray_sep();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c61(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_sep() {
          var s0;
          var key = peg$currPos * 49 + 31, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseS();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecomment();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 32, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c64;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseinline_table_assignment();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseinline_table_assignment();
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s5 = peg$c66;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c67);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c68(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table_assignment() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 33, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c18;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseS();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseS();
                      }
                      if (s7 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s8 = peg$c62;
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c63);
                          }
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = [];
                          s10 = peg$parseS();
                          while (s10 !== peg$FAILED) {
                            s9.push(s10);
                            s10 = peg$parseS();
                          }
                          if (s9 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c69(s2, s6);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s4 = peg$c18;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsevalue();
                      if (s6 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c69(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesecfragment() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 34, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c16;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDIGITS();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c70(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedate() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
          var key = peg$currPos * 49 + 35, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseDIGIT_OR_UNDER();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s6 = peg$c47;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c48);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseDIGIT_OR_UNDER();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                          s9 = peg$c47;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c48);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseDIGIT_OR_UNDER();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseDIGIT_OR_UNDER();
                            if (s11 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c71(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 36, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c72;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                            s1 = s2;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime_with_offset() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
          var key = peg$currPos * 49 + 37, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c72;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 45) {
                              s11 = peg$c47;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c48);
                              }
                            }
                            if (s11 === peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 43) {
                                s11 = peg$c44;
                                peg$currPos++;
                              } else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c45);
                                }
                              }
                            }
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parseDIGIT_OR_UNDER();
                              if (s12 !== peg$FAILED) {
                                s13 = peg$parseDIGIT_OR_UNDER();
                                if (s13 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 58) {
                                    s14 = peg$c72;
                                    peg$currPos++;
                                  } else {
                                    s14 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c73);
                                    }
                                  }
                                  if (s14 !== peg$FAILED) {
                                    s15 = peg$parseDIGIT_OR_UNDER();
                                    if (s15 !== peg$FAILED) {
                                      s16 = peg$parseDIGIT_OR_UNDER();
                                      if (s16 !== peg$FAILED) {
                                        s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                        s1 = s2;
                                      } else {
                                        peg$currPos = s1;
                                        s1 = peg$c2;
                                      }
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedatetime() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 38, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s2 = peg$c75;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetime();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 90) {
                  s4 = peg$c77;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c78);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c79(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedate();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 84) {
                s2 = peg$c75;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c76);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetime_with_offset();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c80(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseS() {
          var s0;
          var key = peg$currPos * 49 + 39, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c81.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNL() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 40, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c83;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 13) {
              s1 = peg$c85;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c83;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNLS() {
          var s0;
          var key = peg$currPos * 49 + 41, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parseS();
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseEOF() {
          var s0, s1;
          var key = peg$currPos * 49 + 42, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          peg$silentFails++;
          if (input.length > peg$currPos) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = peg$c5;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseHEX() {
          var s0;
          var key = peg$currPos * 49 + 43, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c87.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGIT_OR_UNDER() {
          var s0, s1;
          var key = peg$currPos * 49 + 44, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c89.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 95) {
              s1 = peg$c91;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c93();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseASCII_BASIC() {
          var s0;
          var key = peg$currPos * 49 + 45, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c94.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c95);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGITS() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 46, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c96(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED() {
          var s0, s1;
          var key = peg$currPos * 49 + 47, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c99();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c100) {
              s1 = peg$c100;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c101);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c102();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c103) {
                s1 = peg$c103;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c104);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c105();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c106) {
                  s1 = peg$c106;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c107);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c108();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c109) {
                    s1 = peg$c109;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c110);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c111();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c112) {
                      s1 = peg$c112;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c113);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c114();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c115) {
                        s1 = peg$c115;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c116);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c117();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseESCAPED_UNICODE();
                      }
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED_UNICODE() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 48, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c118) {
            s1 = peg$c118;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c119);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHEX();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHEX();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHEX();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseHEX();
                          if (s10 !== peg$FAILED) {
                            s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                            s2 = s3;
                          } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c121) {
              s1 = peg$c121;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c122);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseHEX();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHEX();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseHEX();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c120(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        var nodes = [];
        function genError(err2, line2, col) {
          var ex = new Error(err2);
          ex.line = line2;
          ex.column = col;
          throw ex;
        }
        function addNode(node2) {
          nodes.push(node2);
        }
        function node(type2, value, line2, column2, key) {
          var obj = { type: type2, value, line: line2(), column: column2() };
          if (key)
            obj.key = key;
          return obj;
        }
        function convertCodePoint(str2, line2, col) {
          var num = parseInt("0x" + str2);
          if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
            genError("Invalid Unicode escape code: " + str2, line2, col);
          } else {
            return fromCodePoint(num);
          }
        }
        function fromCodePoint() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 == length || codeUnits.length > MAX_SIZE) {
              result += String.fromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input" });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
      }
      return {
        SyntaxError,
        parse: parse2
      };
    }();
  }
});

// node_modules/toml/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/toml/lib/compiler.js"(exports2, module) {
    init_define_process_env();
    "use strict";
    function compile(nodes) {
      var assignedPaths = [];
      var valueAssignments = [];
      var currentPath = "";
      var data = Object.create(null);
      var context = data;
      var arrayMode = false;
      return reduce(nodes);
      function reduce(nodes2) {
        var node;
        for (var i = 0; i < nodes2.length; i++) {
          node = nodes2[i];
          switch (node.type) {
            case "Assign":
              assign2(node);
              break;
            case "ObjectPath":
              setPath(node);
              break;
            case "ArrayPath":
              addTableArray(node);
              break;
          }
        }
        return data;
      }
      function genError(err2, line, col) {
        var ex = new Error(err2);
        ex.line = line;
        ex.column = col;
        throw ex;
      }
      function assign2(node) {
        var key = node.key;
        var value = node.value;
        var line = node.line;
        var column = node.column;
        var fullPath;
        if (currentPath) {
          fullPath = currentPath + "." + key;
        } else {
          fullPath = key;
        }
        if (typeof context[key] !== "undefined") {
          genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
        }
        context[key] = reduceValueNode(value);
        if (!pathAssigned(fullPath)) {
          assignedPaths.push(fullPath);
          valueAssignments.push(fullPath);
        }
      }
      function pathAssigned(path) {
        return assignedPaths.indexOf(path) !== -1;
      }
      function reduceValueNode(node) {
        if (node.type === "Array") {
          return reduceArrayWithTypeChecking(node.value);
        } else if (node.type === "InlineTable") {
          return reduceInlineTableNode(node.value);
        } else {
          return node.value;
        }
      }
      function reduceInlineTableNode(values) {
        var obj = Object.create(null);
        for (var i = 0; i < values.length; i++) {
          var val = values[i];
          if (val.value.type === "InlineTable") {
            obj[val.key] = reduceInlineTableNode(val.value.value);
          } else if (val.type === "InlineTableValue") {
            obj[val.key] = reduceValueNode(val.value);
          }
        }
        return obj;
      }
      function setPath(node) {
        var path = node.value;
        var quotedPath = path.map(quoteDottedString).join(".");
        var line = node.line;
        var column = node.column;
        if (pathAssigned(quotedPath)) {
          genError("Cannot redefine existing key '" + path + "'.", line, column);
        }
        assignedPaths.push(quotedPath);
        context = deepRef(data, path, Object.create(null), line, column);
        currentPath = path;
      }
      function addTableArray(node) {
        var path = node.value;
        var quotedPath = path.map(quoteDottedString).join(".");
        var line = node.line;
        var column = node.column;
        if (!pathAssigned(quotedPath)) {
          assignedPaths.push(quotedPath);
        }
        assignedPaths = assignedPaths.filter(function(p) {
          return p.indexOf(quotedPath) !== 0;
        });
        assignedPaths.push(quotedPath);
        context = deepRef(data, path, [], line, column);
        currentPath = quotedPath;
        if (context instanceof Array) {
          var newObj = Object.create(null);
          context.push(newObj);
          context = newObj;
        } else {
          genError("Cannot redefine existing key '" + path + "'.", line, column);
        }
      }
      function deepRef(start, keys, value, line, column) {
        var traversed = [];
        var traversedPath = "";
        var path = keys.join(".");
        var ctx = start;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          traversed.push(key);
          traversedPath = traversed.join(".");
          if (typeof ctx[key] === "undefined") {
            if (i === keys.length - 1) {
              ctx[key] = value;
            } else {
              ctx[key] = Object.create(null);
            }
          } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
            genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
          }
          ctx = ctx[key];
          if (ctx instanceof Array && ctx.length && i < keys.length - 1) {
            ctx = ctx[ctx.length - 1];
          }
        }
        return ctx;
      }
      function reduceArrayWithTypeChecking(array3) {
        var firstType = null;
        for (var i = 0; i < array3.length; i++) {
          var node = array3[i];
          if (firstType === null) {
            firstType = node.type;
          } else {
            if (node.type !== firstType) {
              genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
            }
          }
        }
        return array3.map(reduceValueNode);
      }
      function quoteDottedString(str2) {
        if (str2.indexOf(".") > -1) {
          return '"' + str2 + '"';
        } else {
          return str2;
        }
      }
    }
    module.exports = {
      compile
    };
  }
});

// node_modules/toml/index.js
var require_toml = __commonJS({
  "node_modules/toml/index.js"(exports2, module) {
    init_define_process_env();
    var parser = require_parser();
    var compiler = require_compiler();
    module.exports = {
      parse: function(input) {
        var nodes = parser.parse(input.toString());
        return compiler.compile(nodes);
      }
    };
  }
});

// browser-external:path
var path_exports = {};
__export(path_exports, {
  default: () => path_default
});
var path_default;
var init_path = __esm({
  "browser-external:path"() {
    init_define_process_env();
    path_default = new Proxy({}, {
      get() {
        throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/@project-serum/anchor/dist/esm/workspace.js
var workspace_exports = {};
__export(workspace_exports, {
  default: () => workspace_default
});
function attachWorkspaceOverride(workspaceCache, overrideConfig, idlMap) {
  Object.keys(overrideConfig).forEach((programName) => {
    const wsProgramName = (0, import_camelcase11.default)(programName, { pascalCase: true });
    const entry = overrideConfig[programName];
    const overrideAddress = new PublicKey(typeof entry === "string" ? entry : entry.address);
    let idl = idlMap.get(programName);
    if (typeof entry !== "string" && entry.idl) {
      idl = JSON.parse((init_fs(), fs_exports).readFileSync(entry.idl, "utf-8"));
    }
    if (!idl) {
      throw new Error(`Error loading workspace IDL for ${programName}`);
    }
    workspaceCache[wsProgramName] = new Program(idl, overrideAddress);
  });
}
var import_camelcase11, toml, _populatedWorkspace, workspace, workspace_default;
var init_workspace = __esm({
  "node_modules/@project-serum/anchor/dist/esm/workspace.js"() {
    init_define_process_env();
    import_camelcase11 = __toModule(require_camelcase());
    toml = __toModule(require_toml());
    init_index_browser_esm();
    init_program();
    init_common();
    _populatedWorkspace = false;
    workspace = new Proxy({}, {
      get(workspaceCache, programName) {
        if (isBrowser) {
          throw new Error("Workspaces aren't available in the browser");
        }
        const fs = (init_fs(), fs_exports);
        const process2 = require_browser();
        if (!_populatedWorkspace) {
          const path = (init_path(), path_exports);
          let projectRoot = process2.cwd();
          while (!fs.existsSync(path.join(projectRoot, "Anchor.toml"))) {
            const parentDir = path.dirname(projectRoot);
            if (parentDir === projectRoot) {
              projectRoot = void 0;
            }
            projectRoot = parentDir;
          }
          if (projectRoot === void 0) {
            throw new Error("Could not find workspace root.");
          }
          const idlFolder = `${projectRoot}/target/idl`;
          if (!fs.existsSync(idlFolder)) {
            throw new Error(`${idlFolder} doesn't exist. Did you use "anchor build"?`);
          }
          const idlMap = new Map();
          fs.readdirSync(idlFolder).filter((file) => file.endsWith(".json")).forEach((file) => {
            const filePath = `${idlFolder}/${file}`;
            const idlStr = fs.readFileSync(filePath);
            const idl = JSON.parse(idlStr);
            idlMap.set(idl.name, idl);
            const name = (0, import_camelcase11.default)(idl.name, { pascalCase: true });
            if (idl.metadata && idl.metadata.address) {
              workspaceCache[name] = new Program(idl, new PublicKey(idl.metadata.address));
            }
          });
          const anchorToml = toml.parse(fs.readFileSync(path.join(projectRoot, "Anchor.toml"), "utf-8"));
          const clusterId = anchorToml.provider.cluster;
          if (anchorToml.programs && anchorToml.programs[clusterId]) {
            attachWorkspaceOverride(workspaceCache, anchorToml.programs[clusterId], idlMap);
          }
          _populatedWorkspace = true;
        }
        return workspaceCache[programName];
      }
    });
    workspace_default = workspace;
  }
});

// dep:@project-serum_anchor
init_define_process_env();

// node_modules/@project-serum/anchor/dist/esm/index.js
init_define_process_env();
init_nodewallet();
init_common();
var import_bn4 = __toModule(require_bn());
init_index_browser_esm();
init_provider();
init_error();
init_coder();

// node_modules/@project-serum/anchor/dist/esm/utils/index.js
var utils_exports = {};
__export(utils_exports, {
  bytes: () => bytes_exports,
  features: () => features_exports,
  publicKey: () => pubkey_exports,
  registry: () => registry_exports,
  rpc: () => rpc_exports,
  sha256: () => sha256_exports,
  token: () => token_exports
});
init_define_process_env();

// node_modules/@project-serum/anchor/dist/esm/utils/sha256.js
var sha256_exports = {};
__export(sha256_exports, {
  hash: () => hash
});
init_define_process_env();
var import_js_sha2565 = __toModule(require_sha256());
function hash(data) {
  return (0, import_js_sha2565.sha256)(data);
}

// node_modules/@project-serum/anchor/dist/esm/utils/index.js
init_rpc();
init_pubkey();
init_bytes();
init_token();
init_features();

// node_modules/@project-serum/anchor/dist/esm/utils/registry.js
var registry_exports = {};
__export(registry_exports, {
  decodeUpgradeableLoaderState: () => decodeUpgradeableLoaderState,
  fetchData: () => fetchData,
  verifiedBuild: () => verifiedBuild
});
init_define_process_env();
var import_cross_fetch = __toModule(require_browser_ponyfill());
var borsh3 = __toModule(require_lib());
async function verifiedBuild(connection, programId, limit = 5) {
  const url = `https://api.apr.dev/api/v0/program/${programId.toString()}/latest?limit=${limit}`;
  const [programData, latestBuildsResp] = await Promise.all([
    fetchData(connection, programId),
    (0, import_cross_fetch.default)(url)
  ]);
  const latestBuilds = (await latestBuildsResp.json()).filter((b) => !b.aborted && b.state === "Built" && b.verified === "Verified");
  if (latestBuilds.length === 0) {
    return null;
  }
  const build = latestBuilds[0];
  if (programData.slot.toNumber() !== build.verified_slot) {
    return null;
  }
  return build;
}
async function fetchData(connection, programId) {
  const accountInfo = await connection.getAccountInfo(programId);
  if (accountInfo === null) {
    throw new Error("program account not found");
  }
  const { program: program4 } = decodeUpgradeableLoaderState(accountInfo.data);
  const programdataAccountInfo = await connection.getAccountInfo(program4.programdataAddress);
  if (programdataAccountInfo === null) {
    throw new Error("program data account not found");
  }
  const { programData } = decodeUpgradeableLoaderState(programdataAccountInfo.data);
  return programData;
}
var UPGRADEABLE_LOADER_STATE_LAYOUT = borsh3.rustEnum([
  borsh3.struct([], "uninitialized"),
  borsh3.struct([borsh3.option(borsh3.publicKey(), "authorityAddress")], "buffer"),
  borsh3.struct([borsh3.publicKey("programdataAddress")], "program"),
  borsh3.struct([
    borsh3.u64("slot"),
    borsh3.option(borsh3.publicKey(), "upgradeAuthorityAddress")
  ], "programData")
], void 0, borsh3.u32());
function decodeUpgradeableLoaderState(data) {
  return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);
}

// node_modules/@project-serum/anchor/dist/esm/index.js
init_program();

// node_modules/@project-serum/anchor/dist/esm/spl/index.js
init_define_process_env();

// node_modules/@project-serum/anchor/dist/esm/spl/associated-token.js
init_define_process_env();
init_index_browser_esm();
init_program();

// node_modules/@project-serum/anchor/dist/esm/coder/spl-associated-token/index.js
init_define_process_env();

// node_modules/@project-serum/anchor/dist/esm/coder/spl-associated-token/instruction.js
init_define_process_env();
var import_camelcase10 = __toModule(require_camelcase());
var SplAssociatedTokenInstructionCoder = class {
  constructor(_) {
  }
  encode(ixName, _) {
    switch ((0, import_camelcase10.default)(ixName)) {
      case "create": {
        return Buffer.alloc(0);
      }
      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }
  encodeState(_ixName, _ix) {
    throw new Error("SPL associated token does not have state");
  }
};

// node_modules/@project-serum/anchor/dist/esm/coder/spl-associated-token/state.js
init_define_process_env();
var SplAssociatedTokenStateCoder = class {
  constructor(_idl) {
  }
  encode(_name, _account) {
    throw new Error("SPL associated token does not have state");
  }
  decode(_ix) {
    throw new Error("SPL associated token does not have state");
  }
};

// node_modules/@project-serum/anchor/dist/esm/coder/spl-associated-token/accounts.js
init_define_process_env();
init_common3();
var SplAssociatedTokenAccountsCoder = class {
  constructor(idl) {
    this.idl = idl;
  }
  async encode(accountName, account) {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }
  decode(accountName, ix) {
    return this.decodeUnchecked(accountName, ix);
  }
  decodeUnchecked(accountName, ix) {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }
  memcmp(accountName, _appendData) {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }
  size(idlAccount) {
    var _a2;
    return (_a2 = accountSize(this.idl, idlAccount)) !== null && _a2 !== void 0 ? _a2 : 0;
  }
};

// node_modules/@project-serum/anchor/dist/esm/coder/spl-associated-token/events.js
init_define_process_env();
var SplAssociatedTokenEventsCoder = class {
  constructor(_idl) {
  }
  decode(_log) {
    throw new Error("SPL associated token program does not have events");
  }
};

// node_modules/@project-serum/anchor/dist/esm/coder/spl-associated-token/types.js
init_define_process_env();
var SplAssociatedTokenTypesCoder = class {
  constructor(_idl) {
  }
  encode(_name, _type) {
    throw new Error("SPL associated token does not have user-defined types");
  }
  decode(_name, _typeData) {
    throw new Error("SPL associated token does not have user-defined types");
  }
};

// node_modules/@project-serum/anchor/dist/esm/coder/spl-associated-token/index.js
var SplAssociatedTokenCoder = class {
  constructor(idl) {
    this.instruction = new SplAssociatedTokenInstructionCoder(idl);
    this.accounts = new SplAssociatedTokenAccountsCoder(idl);
    this.events = new SplAssociatedTokenEventsCoder(idl);
    this.state = new SplAssociatedTokenStateCoder(idl);
    this.types = new SplAssociatedTokenTypesCoder(idl);
  }
};

// node_modules/@project-serum/anchor/dist/esm/spl/associated-token.js
var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
function program2(provider) {
  return new Program(IDL2, ASSOCIATED_TOKEN_PROGRAM_ID, provider, coder2());
}
function coder2() {
  return new SplAssociatedTokenCoder(IDL2);
}
var IDL2 = {
  version: "0.1.0",
  name: "spl_associated_token",
  instructions: [
    {
      name: "create",
      accounts: [
        {
          name: "authority",
          isMut: true,
          isSigner: true
        },
        {
          name: "associatedAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "owner",
          isMut: false,
          isSigner: false
        },
        {
          name: "mint",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    }
  ]
};

// node_modules/@project-serum/anchor/dist/esm/spl/index.js
init_token2();
var Spl = class {
  static token(provider) {
    return program(provider);
  }
  static associatedToken(provider) {
    return program2(provider);
  }
};

// node_modules/@project-serum/anchor/dist/esm/native/index.js
init_define_process_env();

// node_modules/@project-serum/anchor/dist/esm/native/system.js
init_define_process_env();
init_index_browser_esm();
init_program();
init_system();
var SYSTEM_PROGRAM_ID = new PublicKey("11111111111111111111111111111111");
function program3(provider) {
  return new Program(IDL3, SYSTEM_PROGRAM_ID, provider, coder3());
}
function coder3() {
  return new SystemCoder(IDL3);
}
var IDL3 = {
  version: "0.1.0",
  name: "system_program",
  instructions: [
    {
      name: "createAccount",
      accounts: [
        {
          name: "from",
          isMut: true,
          isSigner: true
        },
        {
          name: "to",
          isMut: true,
          isSigner: true
        }
      ],
      args: [
        {
          name: "lamports",
          type: "u64"
        },
        {
          name: "space",
          type: "u64"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "assign",
      accounts: [
        {
          name: "pubkey",
          isMut: true,
          isSigner: true
        }
      ],
      args: [
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "transfer",
      accounts: [
        {
          name: "from",
          isMut: true,
          isSigner: true
        },
        {
          name: "to",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "lamports",
          type: "u64"
        }
      ]
    },
    {
      name: "createAccountWithSeed",
      accounts: [
        {
          name: "from",
          isMut: true,
          isSigner: true
        },
        {
          name: "to",
          isMut: true,
          isSigner: false
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "base",
          type: "publicKey"
        },
        {
          name: "seed",
          type: "string"
        },
        {
          name: "lamports",
          type: "u64"
        },
        {
          name: "space",
          type: "u64"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "advanceNonceAccount",
      accounts: [
        {
          name: "nonce",
          isMut: true,
          isSigner: false
        },
        {
          name: "recentBlockhashes",
          isMut: false,
          isSigner: false
        },
        {
          name: "authorized",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "authorized",
          type: "publicKey"
        }
      ]
    },
    {
      name: "withdrawNonceAccount",
      accounts: [
        {
          name: "nonce",
          isMut: true,
          isSigner: false
        },
        {
          name: "to",
          isMut: true,
          isSigner: false
        },
        {
          name: "recentBlockhashes",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false
        },
        {
          name: "authorized",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "lamports",
          type: "u64"
        }
      ]
    },
    {
      name: "initializeNonceAccount",
      accounts: [
        {
          name: "nonce",
          isMut: true,
          isSigner: true
        },
        {
          name: "recentBlockhashes",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "authorized",
          type: "publicKey"
        }
      ]
    },
    {
      name: "authorizeNonceAccount",
      accounts: [
        {
          name: "nonce",
          isMut: true,
          isSigner: false
        },
        {
          name: "authorized",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "authorized",
          type: "publicKey"
        }
      ]
    },
    {
      name: "allocate",
      accounts: [
        {
          name: "pubkey",
          isMut: true,
          isSigner: true
        }
      ],
      args: [
        {
          name: "space",
          type: "u64"
        }
      ]
    },
    {
      name: "allocateWithSeed",
      accounts: [
        {
          name: "account",
          isMut: true,
          isSigner: false
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "base",
          type: "publicKey"
        },
        {
          name: "seed",
          type: "string"
        },
        {
          name: "space",
          type: "u64"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "assignWithSeed",
      accounts: [
        {
          name: "account",
          isMut: true,
          isSigner: false
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        }
      ],
      args: [
        {
          name: "base",
          type: "publicKey"
        },
        {
          name: "seed",
          type: "string"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    },
    {
      name: "transferWithSeed",
      accounts: [
        {
          name: "from",
          isMut: true,
          isSigner: false
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        },
        {
          name: "to",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "lamports",
          type: "u64"
        },
        {
          name: "seed",
          type: "string"
        },
        {
          name: "owner",
          type: "publicKey"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "nonce",
      type: {
        kind: "struct",
        fields: [
          {
            name: "version",
            type: "u32"
          },
          {
            name: "state",
            type: "u32"
          },
          {
            name: "authorizedPubkey",
            type: "publicKey"
          },
          {
            name: "nonce",
            type: "publicKey"
          },
          {
            name: "feeCalculator",
            type: {
              defined: "FeeCalculator"
            }
          }
        ]
      }
    }
  ],
  types: [
    {
      name: "FeeCalculator",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lamportsPerSignature",
            type: "u64"
          }
        ]
      }
    }
  ]
};

// node_modules/@project-serum/anchor/dist/esm/native/index.js
var Native = class {
  static system(provider) {
    return program3(provider);
  }
};

// node_modules/@project-serum/anchor/dist/esm/index.js
if (!isBrowser) {
  exports.workspace = (init_workspace(), workspace_exports).default;
  exports.Wallet = (init_nodewallet(), nodewallet_exports).default;
}
var export_BN = import_bn4.default;
export {
  ACCOUNT_DISCRIMINATOR_SIZE,
  AccountClient,
  AnchorError,
  AnchorProvider,
  export_BN as BN,
  BorshAccountsCoder,
  BorshCoder,
  BorshEventCoder,
  BorshInstructionCoder,
  BorshStateCoder,
  EventManager,
  EventParser,
  IdlError,
  LangErrorCode,
  LangErrorMessage,
  MethodsBuilderFactory,
  Native,
  Program,
  ProgramError,
  ProgramErrorStack,
  Spl,
  SplTokenCoder,
  StateClient,
  SystemCoder,
  eventDiscriminator,
  getProvider,
  parseIdlErrors,
  setProvider,
  splitArgsAndCtx,
  stateDiscriminator,
  toInstruction,
  translateAddress,
  translateError,
  utils_exports as utils,
  validateAccounts,
  index_browser_esm_exports as web3
};
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
/**
 * Support for translating between Buffer instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */
//# sourceMappingURL=@project-serum_anchor.js.map
