import {
  require_sha256
} from "./chunk-E6HQ72IU.js";
import {
  index_browser_esm_exports,
  init_index_browser_esm,
  require_bn
} from "./chunk-6Q2MDK6K.js";
import {
  require_buffer
} from "./chunk-ERRUAREY.js";
import {
  __commonJS,
  init_define_process_env
} from "./chunk-KP4UBDXM.js";

// node_modules/@project-serum/anchor/dist/cjs/program/common.js
var require_common = __commonJS({
  "node_modules/@project-serum/anchor/dist/cjs/program/common.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.translateAddress = exports.validateAccounts = exports.toInstruction = exports.parseIdlErrors = void 0;
    var web3_js_1 = (init_index_browser_esm(), index_browser_esm_exports);
    function parseIdlErrors(idl) {
      const errors = new Map();
      if (idl.errors) {
        idl.errors.forEach((e) => {
          var _a;
          let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;
          errors.set(e.code, msg);
        });
      }
      return errors;
    }
    exports.parseIdlErrors = parseIdlErrors;
    function toInstruction(idlIx, ...args) {
      if (idlIx.args.length != args.length) {
        throw new Error("Invalid argument length");
      }
      const ix = {};
      let idx = 0;
      idlIx.args.forEach((ixArg) => {
        ix[ixArg.name] = args[idx];
        idx += 1;
      });
      return ix;
    }
    exports.toInstruction = toInstruction;
    function validateAccounts(ixAccounts, accounts = {}) {
      ixAccounts.forEach((acc) => {
        if ("accounts" in acc) {
          validateAccounts(acc.accounts, accounts[acc.name]);
        } else {
          if (accounts[acc.name] === void 0) {
            throw new Error(`Invalid arguments: ${acc.name} not provided.`);
          }
        }
      });
    }
    exports.validateAccounts = validateAccounts;
    function translateAddress(address) {
      return address instanceof web3_js_1.PublicKey ? address : new web3_js_1.PublicKey(address);
    }
    exports.translateAddress = translateAddress;
  }
});

// node_modules/@project-serum/anchor/dist/cjs/utils/pubkey.js
var require_pubkey = __commonJS({
  "node_modules/@project-serum/anchor/dist/cjs/utils/pubkey.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.associated = exports.findProgramAddressSync = exports.createProgramAddressSync = exports.createWithSeedSync = void 0;
    var buffer_1 = require_buffer();
    var bn_js_1 = __importDefault(require_bn());
    var js_sha256_1 = require_sha256();
    var web3_js_1 = (init_index_browser_esm(), index_browser_esm_exports);
    var common_js_1 = require_common();
    function createWithSeedSync(fromPublicKey, seed, programId) {
      const buffer = buffer_1.Buffer.concat([
        fromPublicKey.toBuffer(),
        buffer_1.Buffer.from(seed),
        programId.toBuffer()
      ]);
      const hash = js_sha256_1.sha256.digest(buffer);
      return new web3_js_1.PublicKey(buffer_1.Buffer.from(hash));
    }
    exports.createWithSeedSync = createWithSeedSync;
    function createProgramAddressSync(seeds, programId) {
      const MAX_SEED_LENGTH = 32;
      let buffer = buffer_1.Buffer.alloc(0);
      seeds.forEach(function(seed) {
        if (seed.length > MAX_SEED_LENGTH) {
          throw new TypeError(`Max seed length exceeded`);
        }
        buffer = buffer_1.Buffer.concat([buffer, toBuffer(seed)]);
      });
      buffer = buffer_1.Buffer.concat([
        buffer,
        programId.toBuffer(),
        buffer_1.Buffer.from("ProgramDerivedAddress")
      ]);
      let hash = (0, js_sha256_1.sha256)(new Uint8Array(buffer));
      let publicKeyBytes = new bn_js_1.default(hash, 16).toArray(void 0, 32);
      if (web3_js_1.PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {
        throw new Error(`Invalid seeds, address must fall off the curve`);
      }
      return new web3_js_1.PublicKey(publicKeyBytes);
    }
    exports.createProgramAddressSync = createProgramAddressSync;
    function findProgramAddressSync(seeds, programId) {
      let nonce = 255;
      let address;
      while (nonce != 0) {
        try {
          const seedsWithNonce = seeds.concat(buffer_1.Buffer.from([nonce]));
          address = createProgramAddressSync(seedsWithNonce, programId);
        } catch (err) {
          if (err instanceof TypeError) {
            throw err;
          }
          nonce--;
          continue;
        }
        return [address, nonce];
      }
      throw new Error(`Unable to find a viable program address nonce`);
    }
    exports.findProgramAddressSync = findProgramAddressSync;
    var toBuffer = (arr) => {
      if (arr instanceof buffer_1.Buffer) {
        return arr;
      } else if (arr instanceof Uint8Array) {
        return buffer_1.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
      } else {
        return buffer_1.Buffer.from(arr);
      }
    };
    async function associated(programId, ...args) {
      let seeds = [buffer_1.Buffer.from([97, 110, 99, 104, 111, 114])];
      args.forEach((arg) => {
        seeds.push(arg instanceof buffer_1.Buffer ? arg : (0, common_js_1.translateAddress)(arg).toBuffer());
      });
      const [assoc] = await web3_js_1.PublicKey.findProgramAddress(seeds, (0, common_js_1.translateAddress)(programId));
      return assoc;
    }
    exports.associated = associated;
  }
});

// dep:@project-serum_anchor_dist_cjs_utils_pubkey
init_define_process_env();
var project_serum_anchor_dist_cjs_utils_pubkey_default = require_pubkey();
export {
  project_serum_anchor_dist_cjs_utils_pubkey_default as default
};
//# sourceMappingURL=@project-serum_anchor_dist_cjs_utils_pubkey.js.map
