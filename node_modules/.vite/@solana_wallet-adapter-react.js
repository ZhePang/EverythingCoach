import {
  Connection,
  init_index_browser_esm,
  require_eventemitter3
} from "./chunk-4SJGJPHQ.js";
import {
  require_react
} from "./chunk-DV7FX7GH.js";
import {
  __toModule,
  init_define_process_env
} from "./chunk-KP4UBDXM.js";

// dep:@solana_wallet-adapter-react
init_define_process_env();

// node_modules/@solana/wallet-adapter-react/lib/esm/index.mjs
init_define_process_env();

// node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.mjs
init_define_process_env();
init_index_browser_esm();
var import_react2 = __toModule(require_react());

// node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.mjs
init_define_process_env();
var import_react = __toModule(require_react());
var ConnectionContext = (0, import_react.createContext)({});
function useConnection() {
  return (0, import_react.useContext)(ConnectionContext);
}

// node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.mjs
var ConnectionProvider = ({ children, endpoint, config = { commitment: "confirmed" } }) => {
  const connection = (0, import_react2.useMemo)(() => new Connection(endpoint, config), [endpoint, config]);
  return import_react2.default.createElement(ConnectionContext.Provider, { value: { connection } }, children);
};

// node_modules/@solana/wallet-adapter-react/lib/esm/errors.mjs
init_define_process_env();

// node_modules/@solana/wallet-adapter-react/node_modules/@solana/wallet-adapter-base/lib/esm/index.mjs
init_define_process_env();

// node_modules/@solana/wallet-adapter-react/node_modules/@solana/wallet-adapter-base/lib/esm/adapter.mjs
init_define_process_env();
var import_eventemitter3 = __toModule(require_eventemitter3());

// node_modules/@solana/wallet-adapter-react/node_modules/@solana/wallet-adapter-base/lib/esm/errors.mjs
init_define_process_env();
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};

// node_modules/@solana/wallet-adapter-react/node_modules/@solana/wallet-adapter-base/lib/esm/adapter.mjs
var WalletReadyState;
(function(WalletReadyState2) {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
})(WalletReadyState || (WalletReadyState = {}));

// node_modules/@solana/wallet-adapter-react/node_modules/@solana/wallet-adapter-base/lib/esm/signer.mjs
init_define_process_env();

// node_modules/@solana/wallet-adapter-react/node_modules/@solana/wallet-adapter-base/lib/esm/types.mjs
init_define_process_env();
var WalletAdapterNetwork;
(function(WalletAdapterNetwork2) {
  WalletAdapterNetwork2["Mainnet"] = "mainnet-beta";
  WalletAdapterNetwork2["Testnet"] = "testnet";
  WalletAdapterNetwork2["Devnet"] = "devnet";
})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));

// node_modules/@solana/wallet-adapter-react/lib/esm/errors.mjs
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};

// node_modules/@solana/wallet-adapter-react/lib/esm/useAnchorWallet.mjs
init_define_process_env();
var import_react4 = __toModule(require_react());

// node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.mjs
init_define_process_env();
var import_react3 = __toModule(require_react());
var EMPTY_ARRAY = [];
var DEFAULT_CONTEXT = {
  autoConnect: false,
  connecting: false,
  connected: false,
  disconnecting: false,
  select(_name) {
    console.error(constructMissingProviderErrorMessage("get", "select"));
  },
  connect() {
    return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "connect")));
  },
  disconnect() {
    return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "disconnect")));
  },
  sendTransaction(_transaction, _connection, _options) {
    return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "sendTransaction")));
  },
  signTransaction(_transaction) {
    return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "signTransaction")));
  },
  signAllTransactions(_transaction) {
    return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "signAllTransactions")));
  },
  signMessage(_message) {
    return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "signMessage")));
  }
};
Object.defineProperty(DEFAULT_CONTEXT, "wallets", {
  get() {
    console.error(constructMissingProviderErrorMessage("read", "wallets"));
    return EMPTY_ARRAY;
  }
});
Object.defineProperty(DEFAULT_CONTEXT, "wallet", {
  get() {
    console.error(constructMissingProviderErrorMessage("read", "wallet"));
    return null;
  }
});
Object.defineProperty(DEFAULT_CONTEXT, "publicKey", {
  get() {
    console.error(constructMissingProviderErrorMessage("read", "publicKey"));
    return null;
  }
});
function constructMissingProviderErrorMessage(action, valueName) {
  return `You have tried to  ${action} "${valueName}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext`;
}
var WalletContext = (0, import_react3.createContext)(DEFAULT_CONTEXT);
function useWallet() {
  return (0, import_react3.useContext)(WalletContext);
}

// node_modules/@solana/wallet-adapter-react/lib/esm/useAnchorWallet.mjs
function useAnchorWallet() {
  const { publicKey, signTransaction, signAllTransactions } = useWallet();
  return (0, import_react4.useMemo)(() => publicKey && signTransaction && signAllTransactions ? { publicKey, signTransaction, signAllTransactions } : void 0, [publicKey, signTransaction, signAllTransactions]);
}

// node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.mjs
init_define_process_env();
var import_react5 = __toModule(require_react());
function useLocalStorage(key, defaultState) {
  const state = (0, import_react5.useState)(() => {
    try {
      const value2 = localStorage.getItem(key);
      if (value2)
        return JSON.parse(value2);
    } catch (error) {
      if (typeof window !== "undefined") {
        console.error(error);
      }
    }
    return defaultState;
  });
  const value = state[0];
  const isFirstRender = (0, import_react5.useRef)(true);
  (0, import_react5.useEffect)(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    try {
      if (value === null) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, JSON.stringify(value));
      }
    } catch (error) {
      if (typeof window !== "undefined") {
        console.error(error);
      }
    }
  }, [value]);
  return state;
}

// node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.mjs
init_define_process_env();
var import_react6 = __toModule(require_react());
var initialState = {
  wallet: null,
  adapter: null,
  publicKey: null,
  connected: false
};
var WalletProvider = ({ children, wallets: adapters, autoConnect = false, onError, localStorageKey = "walletName" }) => {
  const [name, setName] = useLocalStorage(localStorageKey, null);
  const [{ wallet, adapter, publicKey, connected }, setState] = (0, import_react6.useState)(initialState);
  const readyState = (adapter === null || adapter === void 0 ? void 0 : adapter.readyState) || WalletReadyState.Unsupported;
  const [connecting, setConnecting] = (0, import_react6.useState)(false);
  const [disconnecting, setDisconnecting] = (0, import_react6.useState)(false);
  const isConnecting = (0, import_react6.useRef)(false);
  const isDisconnecting = (0, import_react6.useRef)(false);
  const isUnloading = (0, import_react6.useRef)(false);
  const [wallets, setWallets] = (0, import_react6.useState)(() => adapters.map((adapter2) => ({
    adapter: adapter2,
    readyState: adapter2.readyState
  })));
  (0, import_react6.useEffect)(() => {
    function handleReadyStateChange(readyState2) {
      setWallets((prevWallets) => {
        const walletIndex = prevWallets.findIndex(({ adapter: adapter2 }) => adapter2.name === this.name);
        if (walletIndex === -1)
          return prevWallets;
        return [
          ...prevWallets.slice(0, walletIndex),
          { ...prevWallets[walletIndex], readyState: readyState2 },
          ...prevWallets.slice(walletIndex + 1)
        ];
      });
    }
    for (const adapter2 of adapters) {
      adapter2.on("readyStateChange", handleReadyStateChange, adapter2);
    }
    return () => {
      for (const adapter2 of adapters) {
        adapter2.off("readyStateChange", handleReadyStateChange, adapter2);
      }
    };
  }, [adapters]);
  (0, import_react6.useEffect)(() => {
    const wallet2 = wallets.find(({ adapter: adapter2 }) => adapter2.name === name);
    if (wallet2) {
      setState({
        wallet: wallet2,
        adapter: wallet2.adapter,
        connected: wallet2.adapter.connected,
        publicKey: wallet2.adapter.publicKey
      });
    } else {
      setState(initialState);
    }
  }, [name, wallets]);
  (0, import_react6.useEffect)(() => {
    if (isConnecting.current || connecting || connected || !autoConnect || !adapter || !(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable))
      return;
    (async function() {
      isConnecting.current = true;
      setConnecting(true);
      try {
        await adapter.connect();
      } catch (error) {
        setName(null);
      } finally {
        setConnecting(false);
        isConnecting.current = false;
      }
    })();
  }, [isConnecting, connecting, connected, autoConnect, adapter, readyState]);
  (0, import_react6.useEffect)(() => {
    function listener() {
      isUnloading.current = true;
    }
    window.addEventListener("beforeunload", listener);
    return () => window.removeEventListener("beforeunload", listener);
  }, [isUnloading]);
  const handleConnect = (0, import_react6.useCallback)(() => {
    if (!adapter)
      return;
    setState((state) => ({ ...state, connected: adapter.connected, publicKey: adapter.publicKey }));
  }, [adapter]);
  const handleDisconnect = (0, import_react6.useCallback)(() => {
    if (!isUnloading.current)
      setName(null);
  }, [isUnloading]);
  const handleError = (0, import_react6.useCallback)((error) => {
    if (!isUnloading.current)
      (onError || console.error)(error);
    return error;
  }, [isUnloading, onError]);
  (0, import_react6.useEffect)(() => {
    if (adapter) {
      adapter.on("connect", handleConnect);
      adapter.on("disconnect", handleDisconnect);
      adapter.on("error", handleError);
      return () => {
        adapter.off("connect", handleConnect);
        adapter.off("disconnect", handleDisconnect);
        adapter.off("error", handleError);
      };
    }
  }, [adapter, handleConnect, handleDisconnect, handleError]);
  (0, import_react6.useEffect)(() => {
    return () => {
      adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();
    };
  }, [adapter]);
  const connect = (0, import_react6.useCallback)(async () => {
    if (isConnecting.current || connecting || disconnecting || connected)
      return;
    if (!adapter)
      throw handleError(new WalletNotSelectedError());
    if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) {
      setName(null);
      if (typeof window !== "undefined") {
        window.open(adapter.url, "_blank");
      }
      throw handleError(new WalletNotReadyError());
    }
    isConnecting.current = true;
    setConnecting(true);
    try {
      await adapter.connect();
    } catch (error) {
      setName(null);
      throw error;
    } finally {
      setConnecting(false);
      isConnecting.current = false;
    }
  }, [isConnecting, connecting, disconnecting, connected, adapter, readyState, handleError]);
  const disconnect = (0, import_react6.useCallback)(async () => {
    if (isDisconnecting.current || disconnecting)
      return;
    if (!adapter)
      return setName(null);
    isDisconnecting.current = true;
    setDisconnecting(true);
    try {
      await adapter.disconnect();
    } catch (error) {
      setName(null);
      throw error;
    } finally {
      setDisconnecting(false);
      isDisconnecting.current = false;
    }
  }, [isDisconnecting, disconnecting, adapter]);
  const sendTransaction = (0, import_react6.useCallback)(async (transaction, connection, options) => {
    if (!adapter)
      throw handleError(new WalletNotSelectedError());
    if (!connected)
      throw handleError(new WalletNotConnectedError());
    return await adapter.sendTransaction(transaction, connection, options);
  }, [adapter, handleError, connected]);
  const signTransaction = (0, import_react6.useMemo)(() => adapter && "signTransaction" in adapter ? async (transaction) => {
    if (!connected)
      throw handleError(new WalletNotConnectedError());
    return await adapter.signTransaction(transaction);
  } : void 0, [adapter, handleError, connected]);
  const signAllTransactions = (0, import_react6.useMemo)(() => adapter && "signAllTransactions" in adapter ? async (transactions) => {
    if (!connected)
      throw handleError(new WalletNotConnectedError());
    return await adapter.signAllTransactions(transactions);
  } : void 0, [adapter, handleError, connected]);
  const signMessage = (0, import_react6.useMemo)(() => adapter && "signMessage" in adapter ? async (message) => {
    if (!connected)
      throw handleError(new WalletNotConnectedError());
    return await adapter.signMessage(message);
  } : void 0, [adapter, handleError, connected]);
  return import_react6.default.createElement(WalletContext.Provider, { value: {
    autoConnect,
    wallets,
    wallet,
    publicKey,
    connected,
    connecting,
    disconnecting,
    select: setName,
    connect,
    disconnect,
    sendTransaction,
    signTransaction,
    signAllTransactions,
    signMessage
  } }, children);
};
export {
  ConnectionContext,
  ConnectionProvider,
  WalletContext,
  WalletNotSelectedError,
  WalletProvider,
  useAnchorWallet,
  useConnection,
  useLocalStorage,
  useWallet
};
//# sourceMappingURL=@solana_wallet-adapter-react.js.map
